<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VLOG旅プランナー v25 (日本地図対応版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <style>
        html, body {
            height: 100%;
            scroll-behavior: smooth;
        }
        body.overflow-hidden {
            overflow: hidden;
        }
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #FFFBF5;
            color: #4A4A4A;
        }
        .active-filter, .tag-btn.active, .map-area-button.active, .tab-btn.active, #submission-tabs button.active, .view-switcher button.active {
            background-color: #D35400 !important;
            border-color: #D35400 !important;
            color: white !important;
            box-shadow: 0 4px 14px 0 rgba(0,0,0,0.1);
        }
        .card {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            cursor: pointer;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .card-content { cursor: default; }
        .favorite-btn, .add-to-plan-btn {
            cursor: pointer;
        }
        
        .tag-btn {
            background-color: #F5F5F5;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            border-radius: 9999px;
            font-weight: 600;
            transition: all 0.3s;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
            flex-shrink: 0;
        }

        #map-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            height: 400px;
            margin: 1rem auto;
        }
        .map-area-button {
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: #F5F5F5;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            border-radius: 9999px;
            font-weight: 700;
            transition: all 0.3s;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            cursor: pointer;
        }

        #japan-map-container {
            position: relative;
            max-width: 500px;
            margin: auto;
        }
        #japan-map-container img {
            width: 100%;
            height: auto;
        }
        .prefecture-map-button {
            position: absolute;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(2px);
            border: 2px solid #D35400;
            color: #D35400;
            font-weight: 700;
            font-size: 10px;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .prefecture-map-button:hover {
            background-color: #D35400;
            color: white;
            transform: translate(-50%, -50%) scale(1.1);
        }


        .favorite-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(4px);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            z-index: 10;
        }
        .favorite-btn svg {
            width: 20px;
            height: 20px;
            stroke: #6b7280;
            stroke-width: 2;
            fill: none;
            transition: all 0.2s ease;
        }
        .favorite-btn.favorited svg {
            fill: #ef4444;
            stroke: #ef4444;
        }
        .favorite-btn:hover {
            transform: scale(1.1);
        }
        #my-plan-panel, #mailbox-panel {
            transition: transform 0.3s ease-in-out;
        }
        .plan-item.dragging {
            opacity: 0.5;
            background: #f0f0f0;
        }
        .transit-time {
            padding-left: 1.5rem;
            position: relative;
            margin-left: 1.25rem;
            border-left: 2px dashed #cbd5e1;
            height: 3rem;
            display: flex;
            align-items: center;
        }
        .transit-time-icon {
            position: absolute;
            left: -0.75rem;
            top: 50%;
            transform: translateY(-50%);
            background: #FFFBF5;
            padding: 0.25rem;
        }

        /* --- Overlay/Modal Base Styles --- */
        .overlay-base {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 50;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .overlay-base.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-base {
            background-color: white;
            border-radius: 1rem; /* 16px */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            transform: translateY(20px);
            transition: transform 0.3s ease;
            width: 100%;
        }
        .overlay-base.visible .modal-base {
            transform: translateY(0);
        }
        
        /* --- Spot Detail Modal Specific Styles --- */
        #modal.overlay-base {
            align-items: flex-start; /* Align to top */
            padding: 2.5rem 1rem; /* 40px 16px */
        }
        #modal-content.modal-base {
            max-width: 56rem; /* 896px */
            max-height: 90vh;
            overflow-y: auto;
            padding: 1.5rem; /* 24px */
        }
        @media (min-width: 640px) {
            #modal-content.modal-base { padding: 2rem; } /* 32px */
        }
        @media (min-width: 768px) {
            #modal-content.modal-base { padding: 2.5rem; } /* 40px */
        }

        .move-handle {
            cursor: grab;
            padding: 0.5rem;
        }
        .move-handle:active {
            cursor: grabbing;
        }

        .profile-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid #D35400;
            cursor: pointer;
        }
        
        .role-badge {
            font-size: 0.7rem;
            padding: 0.1rem 0.5rem;
            border-radius: 9999px;
            font-weight: 700;
        }
        
        .cropper-container {
            max-width: 100%;
        }
        #cropper-image-container {
            height: 40vh;
            max-height: 400px;
        }
        .cropper-view-box,
        .cropper-face {
            border-radius: 50%;
        }
        
        .candidate-image-wrapper.selected {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }

        /* Styles for Admin Edit Form */
        .admin-edit-form input, .admin-edit-form textarea, .admin-edit-form select {
             width: 100%;
             padding: 0.5rem;
             border: 1px solid #ccc;
             border-radius: 0.375rem;
             margin-top: 0.25rem;
        }
        .admin-edit-form .tag-checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            max-height: 150px;
            overflow-y: auto;
            background-color: #f9fafb;
            padding: 0.5rem;
            border-radius: 0.375rem;
        }
        .admin-edit-form .tag-checkbox {
            display: flex;
            align-items: center;
        }

        @supports (-webkit-line-clamp: 3) {
            .line-clamp-3 {
                overflow: hidden;
                text-overflow: ellipsis;
                display: -webkit-box;
                -webkit-line-clamp: 3;
                -webkit-box-orient: vertical;
            }
        }
        
        /* Mobile filter toggle icon rotation */
        #mobile-filter-toggle.open #mobile-filter-toggle-icon {
            transform: rotate(180deg);
        }

        /* Batch Image Update Modal Styles */
        .update-item-grid {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 1rem;
        }
        .update-item-grid img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 0.5rem;
            border: 1px solid #ddd;
        }
        .update-item-arrow {
            font-size: 2rem;
            color: #D35400;
        }
    </style>
</head>
<body class="h-full">

    <!-- Login/Signup Modal -->
    <div id="auth-modal" class="overlay-base visible">
        <div class="modal-base p-6 sm:p-8 max-w-sm text-center">
            <h2 id="auth-title" class="text-2xl font-bold text-[#D35400] mb-4">ログイン</h2>
            <p id="auth-error" class="text-red-500 text-sm mb-4 h-5"></p>
            <div class="space-y-4">
                <input type="text" id="display-name-input" class="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="ユーザー名">
                <input type="email" id="email-input" class="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="メールアドレス">
                <div class="relative">
                    <input type="password" id="password-input" class="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="パスワード">
                    <button id="password-toggle" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500"></button>
                </div>
                 <div class="relative hidden" id="confirm-password-wrapper">
                    <input type="password" id="confirm-password-input" class="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="パスワード（確認用）">
                    <button id="confirm-password-toggle" class="absolute inset-y-0 right-0 px-3 flex items-center text-gray-500"></button>
                </div>
            </div>
            <button id="auth-btn" class="w-full bg-[#E57373] text-white py-2.5 px-5 rounded-lg font-semibold hover:bg-[#D35400] transition-colors mt-6">ログイン</button>
            <div class="my-4 flex items-center">
                <div class="flex-grow border-t border-gray-300"></div>
                <span class="flex-shrink mx-4 text-gray-500 text-sm">または</span>
                <div class="flex-grow border-t border-gray-300"></div>
            </div>
            <button id="guest-login-btn" class="w-full bg-gray-200 text-gray-700 py-2.5 px-5 rounded-lg font-semibold hover:bg-gray-300 transition-colors">ゲストとして続ける</button>
            <p class="mt-6 text-sm">
                <span id="auth-switch-text">アカウントをお持ちでないですか？</span>
                <a href="#" id="auth-switch-link" class="text-blue-600 hover:underline">新規登録はこちら</a>
            </p>
        </div>
    </div>

    <div id="app-container" class="hidden">
        <div id="app" class="container mx-auto p-4 md:p-8 flex flex-col h-full">
            <header class="mb-4 sm:mb-8 flex-shrink-0">
                <div class="flex justify-center sm:justify-end items-center gap-2 flex-wrap mb-4">
                    <div id="admin-controls" class="hidden items-center gap-2">
                        <button id="open-submission-panel-btn" class="p-2 rounded-full hover:bg-gray-200 transition-colors relative">
                            <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg>
                            <span id="submission-badge" class="hidden absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center"></span>
                        </button>
                        <select id="user-switcher" class="text-sm rounded-md border-gray-300 shadow-sm">
                            <option value="">他のユーザーのプランを見る</option>
                        </select>
                    </div>
                    <div id="user-display" class="flex items-center gap-2">
                        <!-- User Icon, Name, and Role will be injected here -->
                    </div>
                    <button id="mailbox-btn" class="p-2 rounded-full hover:bg-gray-200 transition-colors relative">
                        <svg class="w-6 h-6 text-gray-700" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207"></path></svg>
                        <span id="mailbox-badge" class="hidden absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center"></span>
                    </button>
                    <button id="user-settings-btn" class="p-2 rounded-full hover:bg-gray-200 transition-colors">
                        <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066 2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                    </button>
                </div>
                <div class="text-center">
                    <h1 class="text-4xl md:text-5xl font-bold text-[#D35400]">VLOG旅プランナー</h1>
                    <p class="mt-2 md:mt-4 text-base md:text-lg text-gray-600">専門学生のための究極ガイドをインタラクティブに体験！</p>
                </div>
            </header>

            <nav id="app-nav" class="bg-white/70 backdrop-blur-md sticky top-4 z-20 p-2 sm:p-4 rounded-xl shadow-lg mb-6 flex-shrink-0">
                <!-- Mobile Filter Toggle Button -->
                <div class="md:hidden text-center mb-4">
                    <button id="mobile-filter-toggle" class="w-full bg-white py-2 px-4 border border-gray-300 rounded-full shadow-sm font-semibold text-gray-700 flex items-center justify-center">
                        <span id="mobile-filter-toggle-text">フィルターと検索を開く</span>
                        <svg id="mobile-filter-toggle-icon" class="inline-block w-4 h-4 ml-2 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                </div>
                
                <div id="nav-content-wrapper" class="hidden md:block space-y-4">
                    <div class="flex flex-wrap justify-center gap-2">
                        <!-- Prefecture Filter -->
                        <div class="flex items-center gap-2 bg-stone-200 p-1 rounded-full">
                            <label for="prefecture-filter" class="pl-3 text-sm font-bold text-gray-600">都道府県:</label>
                            <select id="prefecture-filter" class="bg-white border-none rounded-full py-2 px-3 text-sm sm:text-base font-semibold focus:ring-2 focus:ring-orange-500">
                                <option value="all">すべての都道府県</option>
                                <!-- Options populated dynamically -->
                            </select>
                        </div>
                        <!-- Category Filters -->
                        <div id="category-filters" class="flex items-center gap-1 bg-stone-200 p-1 rounded-full">
                            <button data-filter="all" class="filter-btn rounded-full py-2 px-3 sm:px-5 text-xs sm:text-base font-semibold transition-all duration-300 active-filter">すべて</button>
                            <button data-filter="観光" class="filter-btn rounded-full py-2 px-3 sm:px-5 text-xs sm:text-base font-semibold transition-all duration-300">📸 観光</button>
                            <button data-filter="グルメ" class="filter-btn rounded-full py-2 px-3 sm:px-5 text-xs sm:text-base font-semibold transition-all duration-300">🍽️ グルメ</button>
                            <button data-filter="favorites" class="filter-btn rounded-full py-2 px-3 sm:px-5 text-xs sm:text-base font-semibold transition-all duration-300">❤️ お気に入り</button>
                        </div>
                    </div>
                    <!-- Search and Sort Controls -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 border-t pt-4">
                        <div class="relative">
                            <input type="text" id="search-input" placeholder="スポット名で検索..." class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-full focus:ring-2 focus:ring-orange-500">
                            <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" /></svg>
                            </div>
                            <div id="search-suggestions" class="absolute z-10 w-full mt-1 bg-white rounded-md shadow-lg hidden"></div>
                        </div>
                        <div class="flex items-center gap-2">
                            <label for="sort-order" class="text-sm font-bold text-gray-600">並び替え:</label>
                            <select id="sort-order" class="bg-white border-gray-300 rounded-full py-2 px-3 text-sm sm:text-base font-semibold focus:ring-2 focus:ring-orange-500 w-full">
                                <option value="default">追加順（新しい順）</option>
                                <option value="default-desc">追加順（古い順）</option>
                                <option value="name-asc">あいうえお順</option>
                                <option value="name-desc">あいうえお順（逆）</option>
                            </select>
                        </div>
                    </div>
                    <div class="flex items-center justify-center gap-2 border-t pt-4 flex-wrap">
                        <button id="open-area-filter-btn" class="w-full sm:w-auto text-sm font-semibold bg-blue-100 text-blue-800 py-2 px-4 rounded-full hover:bg-blue-200 transition-colors disabled:bg-gray-200 disabled:text-gray-500 disabled:cursor-not-allowed" disabled>🗺️ エリアで絞り込み</button>
                        <button id="open-tag-filter-btn" class="w-full sm:w-auto text-sm font-semibold bg-teal-100 text-teal-800 py-2 px-4 rounded-full hover:bg-teal-200 transition-colors"># タグで絞り込み</button>
                        <button id="add-spot-btn" class="w-full sm:w-auto text-sm font-semibold bg-green-100 text-green-800 py-2 px-4 rounded-full hover:bg-green-200 transition-colors">✨ スポットを追加</button>
                    </div>
                </div>
            </nav>

            <main id="main-content" class="flex-grow">
                <section id="list-section">
                    <h2 id="list-title" class="text-2xl font-bold mb-6 text-gray-800 text-center">すべてのスポット</h2>
                    <div id="spots-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6"></div>
                    <div id="loading-indicator" class="text-center py-10">
                        <p class="text-lg text-gray-600">データを読み込んでいます...</p>
                    </div>
                </section>
            </main>

            <footer class="text-center mt-8 py-4 border-t border-stone-200 flex-shrink-0">
                <p class="text-gray-500 text-sm">このアプリケーションは「専門学生のための究極の旅行ガイド」レポートを元に作成されました。</p>
            </footer>
        </div>

        <!-- Add Spot Modal -->
        <div id="add-spot-overlay" class="overlay-base">
            <div class="modal-base max-w-md p-6 overflow-hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-[#D35400]">新しいスポットを提案</h2>
                    <button id="close-add-spot-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                <div id="add-spot-form-content">
                    <p class="text-sm text-gray-600 mb-4">おすすめのスポット情報を入力してください。AIが内容を分析し、管理者の承認後にアプリに追加されます。</p>
                    <div class="space-y-4">
                        <input type="text" id="new-spot-name" class="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="スポットの名称">
                        <input type="url" id="new-spot-url" class="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="公式サイトのURL">
                    </div>
                    <button id="submit-spot-btn" class="w-full bg-green-500 text-white py-2.5 px-5 rounded-lg font-semibold hover:bg-green-600 transition-colors mt-6 flex items-center justify-center gap-2">
                        <div id="submit-spot-spinner" class="hidden w-5 h-5 border-t-2 border-b-2 border-white rounded-full animate-spin"></div>
                        <span>AI分析と提案を送信</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Re-analysis Modal -->
        <div id="re-analysis-overlay" class="overlay-base z-[51]">
            <div class="modal-base max-w-md p-6 overflow-hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-[#D35400]">都道府県の再分析</h2>
                    <button id="close-re-analysis-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                <div>
                    <p class="text-sm text-gray-600 mb-4">AIが都道府県を特定できませんでした。このスポットのGoogleマップURLを貼り付けて、再度分析してください。</p>
                    <div class="space-y-4">
                        <input type="url" id="re-analysis-gmaps-url" class="w-full px-4 py-2 border border-gray-300 rounded-lg" placeholder="GoogleマップのURL">
                    </div>
                    <button id="re-submit-spot-btn" class="w-full bg-orange-500 text-white py-2.5 px-5 rounded-lg font-semibold hover:bg-orange-600 transition-colors mt-6 flex items-center justify-center gap-2">
                        <div id="re-submit-spot-spinner" class="hidden w-5 h-5 border-t-2 border-b-2 border-white rounded-full animate-spin"></div>
                        <span>AIで再分析</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Submission Panel -->
        <div id="submission-panel-overlay" class="overlay-base">
            <div class="modal-base max-w-4xl max-h-[85vh] flex flex-col p-4 sm:p-6 overflow-hidden">
                <div class="flex justify-between items-center mb-4 flex-shrink-0">
                    <h2 class="text-2xl font-bold text-[#D35400]">提案の管理</h2>
                    <button id="close-submission-panel-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                <div id="submission-tabs" class="border-b border-gray-200 mb-4 flex-shrink-0">
                    <nav class="flex space-x-4" aria-label="Tabs">
                        <button data-tab="submissions" class="tab-btn active px-3 py-2 font-medium text-sm rounded-t-lg">
                            スポット提案
                        </button>
                        <button data-tab="image-reports" class="tab-btn relative px-3 py-2 font-medium text-sm rounded-t-lg">
                            画像レポート
                            <span id="image-report-badge" class="hidden absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center"></span>
                        </button>
                    </nav>
                </div>
                <div id="submission-content" class="flex-grow overflow-y-auto">
                    <div id="admin-tools" class="mb-4 p-3 bg-gray-100 rounded-lg border">
                        <h3 class="font-bold text-gray-700 mb-2">管理者用ツール</h3>
                        <button id="batch-update-images-btn" class="text-sm font-semibold bg-indigo-100 text-indigo-800 py-2 px-4 rounded-full hover:bg-indigo-200 transition-colors">
                            🖼️ 全スポットの画像を更新
                        </button>
                    </div>
                    <div id="submission-list" class="space-y-4 py-4"></div>
                </div>
                <div id="image-report-content" class="hidden flex-grow overflow-y-auto">
                     <div id="image-report-list" class="space-y-4 py-4"></div>
                </div>
            </div>
        </div>

        <!-- Batch Image Update Modal -->
        <div id="batch-image-update-overlay" class="overlay-base z-[52]">
            <div class="modal-base max-w-4xl w-full max-h-[90vh] flex flex-col p-6">
                <div class="flex justify-between items-center mb-4 flex-shrink-0">
                    <h2 class="text-2xl font-bold text-[#D35400]">画像の一括更新</h2>
                    <button id="batch-update-close-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                <p class="text-sm text-gray-600 mb-4 flex-shrink-0">プレースホルダー画像をAIが検索した新しい画像に更新します。更新したい項目にチェックを入れてください。</p>
                <div id="batch-update-list-container" class="flex-grow overflow-y-auto border-t border-b py-4 my-4">
                    <!-- Loading state -->
                    <div id="batch-update-loading" class="text-center py-10">
                        <div class="w-8 h-8 border-t-2 border-b-2 border-orange-500 rounded-full animate-spin mx-auto"></div>
                        <p class="mt-4 text-gray-600">更新候補を検索中...</p>
                    </div>
                    <!-- Update items will be injected here -->
                    <div id="batch-update-list" class="hidden space-y-4"></div>
                </div>
                <div class="flex-shrink-0">
                    <div class="flex items-center mb-4">
                        <input type="checkbox" id="batch-update-select-all" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                        <label for="batch-update-select-all" class="ml-2 block text-sm text-gray-900">すべて選択 / 解除</label>
                    </div>
                    <div class="flex justify-end gap-4">
                        <button id="batch-update-cancel-btn" class="py-2 px-6 bg-gray-200 rounded-lg font-semibold hover:bg-gray-300">キャンセル</button>
                        <button id="batch-update-confirm-btn" class="py-2 px-6 bg-blue-500 text-white rounded-lg font-semibold hover:bg-blue-600 disabled:bg-gray-400 disabled:cursor-not-allowed">
                            選択した <span id="batch-update-count">0</span> 件を更新
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- MODIFIED: Batch Update Prefecture Select Modal -->
        <div id="batch-update-prefecture-select-overlay" class="overlay-base z-[53]">
            <div class="modal-base max-w-2xl w-full p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-[#D35400]">画像更新の対象を選択</h2>
                    <div id="batch-update-view-switcher" class="view-switcher flex items-center gap-1 bg-gray-200 p-1 rounded-full">
                        <button data-view="map" class="active filter-btn rounded-full py-1 px-3 text-xs">🗺️ マップ</button>
                        <button data-view="list" class="filter-btn rounded-full py-1 px-3 text-xs">🗂️ リスト</button>
                    </div>
                    <button id="batch-update-prefecture-select-cancel-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                
                <div id="batch-update-prefecture-map-container" class="relative">
                    <img src="https://japaclip.com/files/japan-map.png" alt="日本地図" class="w-full h-auto">
                    <!-- Prefecture buttons will be injected here -->
                </div>

                <div id="batch-update-prefecture-list-container" class="hidden flex flex-col gap-3 max-h-60 overflow-y-auto">
                    <!-- Prefecture list buttons will be injected here -->
                </div>
            </div>
        </div>

        <!-- Area Filter Overlay -->
        <div id="area-filter-overlay" class="overlay-base">
            <div class="modal-base max-w-4xl max-h-[85vh] flex flex-col p-4 sm:p-6 overflow-hidden">
                <div class="flex justify-between items-center mb-4">
                         <div class="flex items-center gap-4">
                             <h2 class="text-2xl font-bold text-[#D35400]">エリアを選択</h2>
                             <div id="area-view-switcher" class="view-switcher flex items-center gap-1 bg-gray-200 p-1 rounded-full">
                                 <button data-view="map" class="filter-btn rounded-full py-1 px-3 text-xs">🗺️ マップ</button>
                                 <button data-view="list" class="filter-btn rounded-full py-1 px-3 text-xs">🗂️ リスト</button>
                             </div>
                         </div>
                    <button id="close-area-filter-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                <div id="area-list-container" class="hidden flex-grow overflow-y-auto flex flex-wrap justify-center content-start gap-3 p-4">
                    <!-- Area buttons will be rendered here -->
                </div>
                <div id="map-container" class="flex-grow relative">
                    <!-- Map will be rendered here -->
                </div>
            </div>
        </div>

        <!-- Tag Filter Overlay -->
        <div id="tag-filter-overlay" class="overlay-base">
              <div class="modal-base max-w-4xl max-h-[85vh] flex flex-col p-4 sm:p-6 overflow-hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-[#D35400]">タグを選択</h2>
                    <button id="close-tag-filter-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                <div id="tag-filters" class="flex-grow overflow-y-auto flex flex-wrap justify-center content-start gap-3"></div>
            </div>
        </div>

        <!-- User Settings Modal -->
        <div id="user-settings-overlay" class="overlay-base">
            <div class="modal-base max-w-md p-6 overflow-hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-[#D35400]">ユーザー設定</h2>
                    <button id="close-user-settings-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                </div>
                <div id="user-settings-content" class="space-y-6">
                    <div id="settings-icon-section">
                        <label class="block text-sm font-medium text-gray-700">アイコン</label>
                        <div class="mt-2 flex items-center gap-4">
                            <img id="settings-icon-preview" src="" class="profile-icon" alt="現在のアイコン">
                            <input type="file" id="icon-upload-input" class="hidden" accept="image/*">
                            <button id="icon-upload-btn" class="bg-white py-2 px-3 border border-gray-300 rounded-md shadow-sm text-sm leading-4 font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                                変更
                            </button>
                        </div>
                    </div>
                    <div id="settings-username-section">
                        <label for="settings-username-input" class="block text-sm font-medium text-gray-700">ユーザー名</label>
                        <div class="mt-1">
                            <input type="text" id="settings-username-input" class="block w-full px-3 py-2 rounded-md focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm border-gray-300 shadow-sm">
                        </div>
                    </div>
                    <div id="settings-email-section">
                        <label class="block text-sm font-medium text-gray-700">メールアドレス</label>
                        <p id="settings-email" class="mt-1 text-lg text-gray-500"></p>
                    </div>
                    <div class="border-t pt-6 space-y-4">
                        <button id="save-settings-btn" class="w-full bg-orange-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-orange-600 transition-colors">設定を保存</button>
                        <button id="logout-btn-settings" class="w-full bg-red-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-600 transition-colors">ログアウト</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Image Cropper Modal -->
        <div id="cropper-overlay" class="overlay-base z-[60]">
            <div class="modal-base max-w-lg p-6 overflow-hidden">
                <h2 class="text-2xl font-bold text-[#D35400] mb-4">アイコンを編集</h2>
                <div id="cropper-image-container" class="mb-4 bg-gray-200">
                    <img id="cropper-image" src="">
                </div>
                <div class="flex justify-end gap-4">
                    <button id="cropper-cancel-btn" class="py-2 px-6 bg-gray-200 rounded-lg font-semibold hover:bg-gray-300">キャンセル</button>
                    <button id="cropper-save-btn" class="py-2 px-6 bg-blue-500 text-white rounded-lg font-semibold hover:bg-blue-600 flex items-center gap-2">
                        <div id="icon-upload-spinner" class="hidden w-5 h-5 border-t-2 border-b-2 border-white rounded-full animate-spin"></div>
                        <span>保存</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmation-overlay" class="overlay-base z-[55]">
              <div class="modal-base max-w-sm p-6 text-center">
                <p id="confirmation-message" class="text-lg mb-6"></p>
                <div class="flex justify-center gap-4">
                    <button id="confirm-cancel-btn" class="py-2 px-6 bg-gray-200 rounded-lg font-semibold hover:bg-gray-300">キャンセル</button>
                    <button id="confirm-action-btn" class="py-2 px-6 text-white rounded-lg font-semibold transition-colors">削除</button>
                </div>
            </div>
        </div>
        
        <!-- Info Modal -->
        <div id="info-overlay" class="overlay-base z-[55]">
            <div class="modal-base max-w-sm p-6 text-center">
                <p id="info-message" class="text-lg mb-6"></p>
                <button id="info-ok-btn" class="py-2 px-10 bg-blue-500 text-white rounded-lg font-semibold hover:bg-blue-600">OK</button>
            </div>
        </div>

        <!-- Cross-Prefecture Confirmation Modal -->
        <div id="cross-prefecture-overlay" class="overlay-base">
            <div class="modal-base max-w-md p-6 text-center">
                <h3 class="text-xl font-bold text-gray-800 mb-2">プラン確認</h3>
                <p id="cross-prefecture-message" class="text-base mb-6"></p>
                <div class="flex flex-col gap-3">
                    <button id="cross-prefecture-add-btn" class="w-full py-2 px-6 bg-orange-500 text-white rounded-lg font-semibold hover:bg-orange-600">そのまま追加する</button>
                    <button id="cross-prefecture-favorite-btn" class="w-full py-2 px-6 bg-teal-500 text-white rounded-lg font-semibold hover:bg-teal-600">お気に入りに入れる</button>
                    <button id="cross-prefecture-cancel-btn" class="w-full py-2 px-6 bg-gray-200 rounded-lg font-semibold hover:bg-gray-300">追加しない</button>
                </div>
            </div>
        </div>

        <!-- Main Content Modal -->
        <div id="modal" class="overlay-base" data-spot-name="">
            <div id="modal-content" class="modal-base">
                 <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="relative">
                        <img id="modal-image" src="" alt="スポットの画像" class="w-full h-auto rounded-lg shadow-md object-cover aspect-video cursor-pointer" onerror="this.onerror=null;this.src='https://placehold.co/600x400/E57373/FFF?text=Image+Not+Found';">
                        <div id="modal-image-spinner" class="absolute inset-0 flex items-center justify-center bg-gray-200 rounded-lg hidden">
                            <div class="w-8 h-8 border-t-2 border-b-2 border-orange-500 rounded-full animate-spin"></div>
                        </div>
                        <a id="modal-image-source" href="#" target="_blank" rel="noopener noreferrer" class="absolute bottom-2 left-2 text-xs bg-black/50 text-white py-1 px-2 rounded hidden"></a>
                        <button id="report-image-btn" class="absolute bottom-2 right-2 bg-red-100 text-red-700 text-xs font-bold py-1 px-2 rounded-full hover:bg-red-200 transition-colors z-10">
                            画像が違いますか？
                        </button>
                    </div>
                    <div>
                        <div class="flex justify-between items-start mb-4">
                            <h3 id="modal-title" class="text-3xl font-bold text-[#D35400] pr-4"></h3>
                            <button id="modal-close" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
                        </div>
                        <div id="modal-tags" class="flex flex-wrap gap-2 mb-4"></div>
                        <p id="modal-description" class="text-gray-700 leading-relaxed"></p>
                        <div class="mt-4 flex items-center gap-2 text-gray-600">
                            <span class="text-xl">⏰</span>
                            <span id="modal-stay-time" class="font-medium"></span>
                        </div>
                        <div class="mt-6 flex flex-wrap gap-4">
                            <a id="modal-website" href="#" target="_blank" rel="noopener noreferrer" class="inline-block bg-[#E57373] text-white py-2 px-5 rounded-full font-semibold hover:bg-[#D35400] transition-colors">公式サイト 🔗</a>
                            <a id="modal-map" href="#" target="_blank" rel="noopener noreferrer" class="inline-block bg-[#E57373] text-white py-2 px-5 rounded-full font-semibold hover:bg-[#D35400] transition-colors">Googleマップ 📍</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <button id="my-plan-btn" class="fixed bottom-6 right-6 bg-[#D35400] text-white w-16 h-16 rounded-full shadow-lg flex items-center justify-center z-30 transform hover:scale-110 transition-transform">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"/></svg>
            <span id="plan-count" class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">0</span>
        </button>

        <div id="my-plan-panel-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden"></div>
        <div id="my-plan-panel" class="fixed top-0 right-0 h-full w-full sm:w-11/12 max-w-md bg-white shadow-2xl z-40 transform translate-x-full p-6 flex flex-col">
            <div class="flex-shrink-0 flex justify-between items-center pb-4 border-b">
                <h2 id="my-plan-title" class="text-2xl font-bold text-[#D35400]">マイプラン</h2>
                <button id="my-plan-close-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
            </div>
            <div id="plan-items-list" class="flex-grow my-4 overflow-y-auto pr-4 min-h-0"></div>
            <div id="plan-controls" class="flex-shrink-0 pt-4 border-t space-y-3">
                <div class="flex justify-between items-center font-bold text-lg">
                    <span>合計目安時間:</span>
                    <span id="plan-total-time" class="text-[#D35400]">0分</span>
                </div>
                <p class="text-sm text-gray-500 -mt-2">※滞在・移動時間はあくまで目安です。</p>
                <div class="flex gap-2 mt-4">
                    <button id="clear-plan-btn" class="w-full bg-red-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-600 transition-colors">一括削除</button>
                    <button id="copy-plan-btn" class="w-full bg-teal-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-teal-600 transition-colors">プランをコピー</button>
                </div>
                <div class="space-y-2 mt-2">
                    <a id="route-map-btn" href="#" target="_blank" rel="noopener noreferrer" class="block w-full text-center bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600 transition-colors">ルートをマップで見る</a>
                    <button id="route-map-from-current-btn" class="w-full bg-green-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-green-600 transition-colors">現在地からルートを見る</button>
                </div>
            </div>
        </div>

        <!-- Mailbox Panel -->
        <div id="mailbox-panel-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden"></div>
        <div id="mailbox-panel" class="fixed top-0 right-0 h-full w-full sm:w-11/12 max-w-md bg-white shadow-2xl z-40 transform translate-x-full p-6 flex flex-col">
            <div class="flex-shrink-0 flex justify-between items-center pb-4 border-b">
                <h2 class="text-2xl font-bold text-[#D35400]">お知らせ</h2>
                <button id="mailbox-close-btn" class="text-3xl font-light text-gray-500 hover:text-gray-900 transition">×</button>
            </div>
            <div id="mailbox-list" class="flex-grow my-4 overflow-y-auto pr-4 min-h-0"></div>
            <div class="flex-shrink-0 pt-4 border-t">
                <button id="mark-all-as-read-btn" class="w-full bg-gray-200 text-gray-700 py-2 px-4 rounded-lg font-semibold hover:bg-gray-300 transition-colors">すべて既読にする</button>
            </div>
        </div>

        <!-- Prefecture Select Modal -->
        <div id="prefecture-select-overlay" class="overlay-base z-[60]">
            <div class="modal-base max-w-sm p-6 text-center">
                <h3 id="prefecture-select-title" class="text-xl font-bold text-gray-800 mb-4"></h3>
                <p id="prefecture-select-message" class="text-base mb-6"></p>
                <div id="prefecture-select-buttons" class="flex flex-col gap-3">
                    <!-- Buttons will be injected here -->
                </div>
                <button id="prefecture-select-cancel-btn" class="w-full mt-4 py-2 px-6 bg-gray-200 rounded-lg font-semibold hover:bg-gray-300">キャンセル</button>
            </div>
        </div>

        <!-- Progress Modal -->
        <div id="progress-overlay" class="overlay-base z-[70]">
            <div class="modal-base max-w-sm p-8 text-center">
                <h3 id="progress-title" class="text-xl font-bold text-gray-800 mb-2">処理中です...</h3>
                <p id="progress-message" class="text-base mb-4"></p>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
        </div>

        <!-- Image Viewer Modal -->
        <div id="image-viewer-overlay" class="overlay-base z-[60] p-4">
            <div class="w-full h-full flex items-center justify-center">
                <img id="image-viewer-img" src="" alt="拡大画像" class="max-w-full max-h-full object-contain rounded-lg shadow-2xl">
            </div>
        </div>
        
        <!-- Image Candidate Selection Modal -->
        <div id="image-candidate-overlay" class="overlay-base z-[52]">
            <div class="modal-base max-w-2xl p-6">
                <h2 class="text-2xl font-bold text-[#D35400] mb-4">新しい画像を選択してください</h2>
                <p class="text-sm text-gray-600 mb-4">AIが取得した画像候補です。スポットに最も適した画像を1つ選択してください。</p>
                <div id="image-candidate-list" class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6 min-h-[10rem]">
                    <!-- Candidates will be injected here -->
                </div>
                <div id="image-candidate-loading" class="text-center py-10 hidden">
                    <div class="w-8 h-8 border-t-2 border-b-2 border-orange-500 rounded-full animate-spin mx-auto"></div>
                    <p class="mt-4 text-gray-600">AIで画像候補を検索中...</p>
                </div>
                <div class="flex justify-end gap-4">
                    <button id="image-candidate-cancel-btn" class="py-2 px-6 bg-gray-200 rounded-lg font-semibold hover:bg-gray-300">キャンセル</button>
                    <button id="image-candidate-confirm-btn" class="py-2 px-6 bg-blue-500 text-white rounded-lg font-semibold hover:bg-blue-600 disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>この画像に決定</button>
                </div>
            </div>
        </div>

    </div>
    
    <textarea id="copy-textarea" class="absolute -left-full"></textarea>

    <!-- Cropper.jsのスクリプトを追加 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script type="module">
        // Firebase SDKのインポート
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            createUserWithEmailAndPassword, 
            signInWithEmailAndPassword, 
            signInAnonymously,
            signOut, 
            onAuthStateChanged,
            updateProfile
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc,
            addDoc,
            collection,
            getDocs,
            onSnapshot,
            updateDoc,
            deleteDoc,
            serverTimestamp,
            query,
            where,
            writeBatch
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { 
            getStorage,
            ref,
            uploadBytes,
            getDownloadURL
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        // Firebase Functions SDKのインポートを追加
        import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-functions.js";


        // Firebase Configuration
        const firebaseConfig = {
          apiKey: "AIzaSyDe8piUl7dbuR_FAn1pQkUfVtugh5HF4FU", // このキーは公開しても安全です
          authDomain: "studio-gqqbe.firebaseapp.com",
          projectId: "studio-gqqbe",
          storageBucket: "studio-gqqbe.appspot.com",
          messagingSenderId: "369252587708",
          appId: "1:369252587708:web:86f2413bd89967e2a858b9"
        };

        // Firebaseサービスの初期化
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        // Functionsサービスを初期化（リージョンを指定）
        const functions = getFunctions(app, 'asia-northeast1');

        // --- DATA (Will be loaded) ---
        let allSpotsData = {};
        let areaPositions = {};
        let allTransitData = {};
        let combinedSpots = [];
        let supportedPrefectureNames = [];
        let originalJsonData = {}; // To store the original structure for saving
        let prefectureMapPositions = {}; // NEW: For Japan map positions
        
        const standardTags = [
            "絶景", "インスタ映え", "レトロ", "おしゃれ", "カワイイ", "ユニーク", "自然・癒し",
            "食べ歩き", "ショッピング", "体験", "アート・建築", "夜景", "定番スポット",
            "カフェ・喫茶店", "スイーツ", "ご当地グルメ", "B級グルメ", "ランチ", "ディナー",
            "雨の日OK", "予約推奨", "コスパ", "無料"
        ];
        
        const subCategories = {
            "観光": ["定番スポット", "絶景", "夜景", "自然・癒し", "アート・建築", "レトロ", "体験"],
            "グルメ": ["カフェ・喫茶店", "スイーツ", "ご当地グルメ", "B級グルメ", "ランチ", "ディナー", "食べ歩き"]
        };

        // --- MODIFIED Data Loading Function ---
        async function loadAllData() {
            const loadingIndicator = document.getElementById('loading-indicator');
            const prefectureFilter = document.getElementById('prefecture-filter');
            loadingIndicator.classList.remove('hidden');
            
            // 1. Fetch the list of available prefectures from the Cloud Function
            let availablePrefectures = [];
            try {
                const getPrefectureList = httpsCallable(functions, 'getPrefectureList');
                const result = await getPrefectureList();
                availablePrefectures = result.data;
            } catch (error) {
                console.error("都道府県リストの取得に失敗しました:", error);
                loadingIndicator.innerHTML = `<p class="text-red-500">都道府県リストの取得に失敗しました。ページを再読み込みしてください。</p>`;
                return false;
            }

            // 2. Dynamically populate the prefecture filter dropdown
            prefectureFilter.innerHTML = '<option value="all">すべての都道府県</option>';
            availablePrefectures.forEach(pref => {
                const option = document.createElement('option');
                option.value = pref.id;
                option.textContent = pref.name;
                prefectureFilter.appendChild(option);
            });

            // 3. Dynamically create the list of files to fetch
            const prefectureFiles = availablePrefectures.map(p => `data/${p.id}.json`);
            
            // 4. Fetch all data files from GitHub
            const localSpots = [];
            supportedPrefectureNames = []; // Reset before loading
            try {
                const owner = 'tatsuya0203';
                const repo = 'trip-planner';
                const branch = 'main';

                // Fetch prefecture data and map positions in parallel
                const responses = await Promise.all([
                    ...prefectureFiles.map(file => fetch(`https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${file}?v=${new Date().getTime()}`)),
                    fetch(`https://raw.githubusercontent.com/${owner}/${repo}/${branch}/data/prefecture_positions.json?v=${new Date().getTime()}`)
                ]);

                const positionResponse = responses.pop();
                if (positionResponse.ok) {
                    prefectureMapPositions = await positionResponse.json();
                } else {
                    console.warn('prefecture_positions.jsonの読み込みに失敗しました。');
                }

                const jsonDataArray = await Promise.all(responses.map(res => {
                    if (!res.ok) throw new Error(`Failed to fetch ${res.url}: ${res.statusText}`);
                    return res.json();
                }));
                
                jsonDataArray.forEach((data, index) => {
                    const prefectureId = prefectureFiles[index].split('/')[1].replace('.json', '');
                    originalJsonData[prefectureId] = data; 
                    allSpotsData[prefectureId] = data.spots;
                    areaPositions[prefectureId] = data.areaPositions;
                    allTransitData[prefectureId] = data.transitData;
                    localSpots.push(...data.spots);
                    if (data.name) {
                        supportedPrefectureNames.push(data.name);
                    }
                });
            } catch (error) {
                console.error("GitHubからのデータ読み込みに失敗しました:", error);
                loadingIndicator.innerHTML = `<p class="text-red-500">データの読み込みに失敗しました。ページを再読み込みしてください。</p>`;
                return false;
            }

            combinedSpots = [...localSpots];

            loadingIndicator.classList.add('hidden');
            return true;
        }


        document.addEventListener('DOMContentLoaded', async () => {
            const dataLoaded = await loadAllData();
            if (!dataLoaded) return;

            // Get all DOM elements
            const appContainer = document.getElementById('app-container');
            const authModal = document.getElementById('auth-modal');
            const authTitle = document.getElementById('auth-title');
            const authBtn = document.getElementById('auth-btn');
            const guestLoginBtn = document.getElementById('guest-login-btn');
            const emailInput = document.getElementById('email-input');
            const displayNameInput = document.getElementById('display-name-input');
            const passwordInput = document.getElementById('password-input');
            const confirmPasswordInput = document.getElementById('confirm-password-input');
            const passwordToggle = document.getElementById('password-toggle');
            const confirmPasswordWrapper = document.getElementById('confirm-password-wrapper');
            const confirmPasswordToggle = document.getElementById('confirm-password-toggle');
            const authSwitchLink = document.getElementById('auth-switch-link');
            const authSwitchText = document.getElementById('auth-switch-text');
            const authError = document.getElementById('auth-error');
            const userDisplay = document.getElementById('user-display');
            const userSettingsBtn = document.getElementById('user-settings-btn');
            const myPlanTitle = document.getElementById('my-plan-title');
            const spotsList = document.getElementById('spots-list');
            const categoryFilters = document.getElementById('category-filters');
            const listTitle = document.getElementById('list-title');
            const openAreaFilterBtn = document.getElementById('open-area-filter-btn');
            const areaFilterOverlay = document.getElementById('area-filter-overlay');
            const closeAreaFilterBtn = document.getElementById('close-area-filter-btn');
            const mapContainer = document.getElementById('map-container');
            const openTagFilterBtn = document.getElementById('open-tag-filter-btn');
            const tagFilterOverlay = document.getElementById('tag-filter-overlay');
            const closeTagFilterBtn = document.getElementById('close-tag-filter-btn');
            const tagFilters = document.getElementById('tag-filters');
            const userSettingsOverlay = document.getElementById('user-settings-overlay');
            const closeUserSettingsBtn = document.getElementById('close-user-settings-btn');
            const settingsIconSection = document.getElementById('settings-icon-section');
            const settingsUsernameSection = document.getElementById('settings-username-section');
            const settingsEmailSection = document.getElementById('settings-email-section');
            const settingsIconPreview = document.getElementById('settings-icon-preview');
            const iconUploadInput = document.getElementById('icon-upload-input');
            const iconUploadBtn = document.getElementById('icon-upload-btn');
            const settingsUsernameInput = document.getElementById('settings-username-input');
            const settingsEmail = document.getElementById('settings-email');
            const logoutBtnSettings = document.getElementById('logout-btn-settings');
            const adminControls = document.getElementById('admin-controls');
            const userSwitcher = document.getElementById('user-switcher');
            const cropperOverlay = document.getElementById('cropper-overlay');
            const cropperImage = document.getElementById('cropper-image');
            const cropperCancelBtn = document.getElementById('cropper-cancel-btn');
            const cropperSaveBtn = document.getElementById('cropper-save-btn');
            const iconUploadSpinner = document.getElementById('icon-upload-spinner');
            const confirmationOverlay = document.getElementById('confirmation-overlay');
            const confirmationMessage = document.getElementById('confirmation-message');
            const confirmActionBtn = document.getElementById('confirm-action-btn');
            const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
            const infoOverlay = document.getElementById('info-overlay');
            const infoMessage = document.getElementById('info-message');
            const infoOkBtn = document.getElementById('info-ok-btn');
            const modal = document.getElementById('modal');
            const modalClose = document.getElementById('modal-close');
            const modalContent = document.getElementById('modal-content');
            const myPlanBtn = document.getElementById('my-plan-btn');
            const planCountBadge = document.getElementById('plan-count');
            const myPlanPanel = document.getElementById('my-plan-panel');
            const myPlanPanelOverlay = document.getElementById('my-plan-panel-overlay');
            const myPlanCloseBtn = document.getElementById('my-plan-close-btn');
            const planItemsList = document.getElementById('plan-items-list');
            const planControls = document.getElementById('plan-controls');
            const planTotalTimeEl = document.getElementById('plan-total-time');
            const copyPlanBtn = document.getElementById('copy-plan-btn');
            const clearPlanBtn = document.getElementById('clear-plan-btn');
            const copyTextarea = document.getElementById('copy-textarea');
            const routeMapBtn = document.getElementById('route-map-btn');
            const routeMapFromCurrentBtn = document.getElementById('route-map-from-current-btn');
            const prefectureFilter = document.getElementById('prefecture-filter');
            const crossPrefectureOverlay = document.getElementById('cross-prefecture-overlay');
            const crossPrefectureMessage = document.getElementById('cross-prefecture-message');
            const crossPrefectureAddBtn = document.getElementById('cross-prefecture-add-btn');
            const crossPrefectureFavoriteBtn = document.getElementById('cross-prefecture-favorite-btn');
            const crossPrefectureCancelBtn = document.getElementById('cross-prefecture-cancel-btn');
            const areaViewSwitcher = document.getElementById('area-view-switcher');
            const areaListContainer = document.getElementById('area-list-container');
            const addSpotBtn = document.getElementById('add-spot-btn');
            const addSpotOverlay = document.getElementById('add-spot-overlay');
            const closeAddSpotBtn = document.getElementById('close-add-spot-btn');
            const submitSpotBtn = document.getElementById('submit-spot-btn');
            const newSpotName = document.getElementById('new-spot-name');
            const newSpotUrl = document.getElementById('new-spot-url');
            const submitSpotSpinner = document.getElementById('submit-spot-spinner');
            const openSubmissionPanelBtn = document.getElementById('open-submission-panel-btn');
            const submissionPanelOverlay = document.getElementById('submission-panel-overlay');
            const closeSubmissionPanelBtn = document.getElementById('close-submission-panel-btn');
            const submissionList = document.getElementById('submission-list');
            const submissionBadge = document.getElementById('submission-badge');
            const modalImageSpinner = document.getElementById('modal-image-spinner');
            const reAnalysisOverlay = document.getElementById('re-analysis-overlay');
            const closeReAnalysisBtn = document.getElementById('close-re-analysis-btn');
            const reAnalysisGmapsUrl = document.getElementById('re-analysis-gmaps-url');
            const reSubmitSpotBtn = document.getElementById('re-submit-spot-btn');
            const reSubmitSpotSpinner = document.getElementById('re-submit-spot-spinner');
            const saveSettingsBtn = document.getElementById('save-settings-btn');
            const mailboxBtn = document.getElementById('mailbox-btn');
            const mailboxBadge = document.getElementById('mailbox-badge');
            const mailboxPanel = document.getElementById('mailbox-panel');
            const mailboxPanelOverlay = document.getElementById('mailbox-panel-overlay');
            const mailboxCloseBtn = document.getElementById('mailbox-close-btn');
            const mailboxList = document.getElementById('mailbox-list');
            const markAllAsReadBtn = document.getElementById('mark-all-as-read-btn');
            const batchUpdateImagesBtn = document.getElementById('batch-update-images-btn');
            const prefectureSelectOverlay = document.getElementById('prefecture-select-overlay');
            const prefectureSelectTitle = document.getElementById('prefecture-select-title');
            const prefectureSelectMessage = document.getElementById('prefecture-select-message');
            const prefectureSelectButtons = document.getElementById('prefecture-select-buttons');
            const prefectureSelectCancelBtn = document.getElementById('prefecture-select-cancel-btn');
            const progressOverlay = document.getElementById('progress-overlay');
            const progressMessage = document.getElementById('progress-message');
            const progressBar = document.getElementById('progress-bar');
            const submissionTabs = document.getElementById('submission-tabs');
            const submissionContent = document.getElementById('submission-content');
            const imageReportContent = document.getElementById('image-report-content');
            const imageReportList = document.getElementById('image-report-list');
            const imageReportBadge = document.getElementById('image-report-badge');
            const reportImageBtn = document.getElementById('report-image-btn');
            const searchInput = document.getElementById('search-input');
            const sortOrder = document.getElementById('sort-order');
            const imageViewerOverlay = document.getElementById('image-viewer-overlay');
            const imageViewerImg = document.getElementById('image-viewer-img');
            const imageCandidateOverlay = document.getElementById('image-candidate-overlay');
            const imageCandidateList = document.getElementById('image-candidate-list');
            const imageCandidateLoading = document.getElementById('image-candidate-loading');
            const imageCandidateConfirmBtn = document.getElementById('image-candidate-confirm-btn');
            const imageCandidateCancelBtn = document.getElementById('image-candidate-cancel-btn');
            const mobileFilterToggle = document.getElementById('mobile-filter-toggle');
            const navContentWrapper = document.getElementById('nav-content-wrapper');
            const mobileFilterToggleText = document.getElementById('mobile-filter-toggle-text');
            const batchImageUpdateOverlay = document.getElementById('batch-image-update-overlay');
            const batchUpdateCloseBtn = document.getElementById('batch-update-close-btn');
            const batchUpdateListContainer = document.getElementById('batch-update-list-container');
            const batchUpdateLoading = document.getElementById('batch-update-loading');
            const batchUpdateList = document.getElementById('batch-update-list');
            const batchUpdateSelectAll = document.getElementById('batch-update-select-all');
            const batchUpdateCancelBtn = document.getElementById('batch-update-cancel-btn');
            const batchUpdateConfirmBtn = document.getElementById('batch-update-confirm-btn');
            const batchUpdateCount = document.getElementById('batch-update-count');
            
            // New elements for prefecture selection
            const batchUpdatePrefectureSelectOverlay = document.getElementById('batch-update-prefecture-select-overlay');
            const batchUpdateViewSwitcher = document.getElementById('batch-update-view-switcher');
            const batchUpdatePrefectureMapContainer = document.getElementById('batch-update-prefecture-map-container');
            const batchUpdatePrefectureListContainer = document.getElementById('batch-update-prefecture-list-container');
            const batchUpdatePrefectureSelectCancelBtn = document.getElementById('batch-update-prefecture-select-cancel-btn');

            let batchUpdatePrefectureView = 'map'; // 'map' or 'list'
            
            let currentPrefecture = 'all';
            let currentFilters = { category: 'all', area: 'all', tag: 'all' };
            let currentSearchTerm = '';
            let currentSortOrder = 'default';
            let activeImageReportData = {};
            let proposedImageUpdates = [];

            let currentUser = null;
            let localFavorites = [];
            let localPlan = [];
            let unsubscribePlan = null;
            let unsubscribeFavorites = null;
            let unsubscribeSpotSubmissions = null;
            let unsubscribeImageReports = null;
            let unsubscribeMailbox = null;
            let unsubscribeAnnouncements = null; // Listener for public announcements
            let localAnnouncements = []; // To store public announcements
            
            let isLoginMode = true;
            let viewedUserId = null;
            let cropper = null;
            let areaFilterView = 'map'; // 'map' or 'list'
            let pendingReAnalysisData = null;
            let pendingSpotSubmissionsCount = 0;
            let pendingImageReportsCount = 0;

            function toggleBodyScroll(lock) {
                document.body.classList.toggle('overflow-hidden', lock);
            }

            function showOverlay(overlayElement) {
                overlayElement.classList.add('visible');
                toggleBodyScroll(true);
            }

            function hideOverlay(overlayElement) {
                overlayElement.classList.remove('visible');
                // Check if any other overlays are still visible before unlocking scroll
                const isAnyOverlayVisible = document.querySelector('.overlay-base.visible');
                if (!isAnyOverlayVisible) {
                    toggleBodyScroll(false);
                }
            }
            
            function showInfoModal(message) {
                infoMessage.textContent = message;
                showOverlay(infoOverlay);
            }
            infoOkBtn.addEventListener('click', () => hideOverlay(infoOverlay));
            infoOverlay.addEventListener('click', (e) => {
                if (e.target === infoOverlay) hideOverlay(infoOverlay);
            });
            
            async function reloadDataAndRefreshUI(successMessage) {
                // Close any open modals to avoid stale data display
                hideOverlay(modal);
                hideOverlay(submissionPanelOverlay);
                hideOverlay(imageCandidateOverlay);
                hideOverlay(batchImageUpdateOverlay);

                // Show a temporary loading/info message
                showInfoModal("データを更新しています...");

                await loadAllData(); // Re-fetch from GitHub
                renderAll(); // Re-render the entire UI with new data

                // Show the final success message
                // Use a short timeout to ensure the user sees the "updating" message first
                setTimeout(() => {
                    showInfoModal(successMessage);
                }, 300);
            }

            onAuthStateChanged(auth, user => {
                if (user) {
                    currentUser = user;
                    viewedUserId = user.uid;
                    hideOverlay(authModal);
                    appContainer.classList.remove('hidden');
                    initAppForUser(user);
                } else {
                    currentUser = null;
                    showOverlay(authModal);
                    appContainer.classList.add('hidden');
                    adminControls.classList.add('hidden');
                    if (unsubscribeSpotSubmissions) unsubscribeSpotSubmissions();
                    if (unsubscribeImageReports) unsubscribeImageReports();
                    if (unsubscribeMailbox) unsubscribeMailbox();
                    if (unsubscribeAnnouncements) unsubscribeAnnouncements();
                }
            });

            function handleAuth() {
                const email = emailInput.value.trim();
                const password = passwordInput.value.trim();
                const displayName = displayNameInput.value.trim();
                authError.textContent = '';

                if (!email || !password) {
                    authError.textContent = 'メールアドレスとパスワードを入力してください。';
                    return;
                }
                if (!isLoginMode && !displayName) {
                    authError.textContent = 'ユーザー名を入力してください。';
                    return;
                }

                if (isLoginMode) {
                    signInWithEmailAndPassword(auth, email, password)
                        .catch(error => {
                            authError.textContent = "メールアドレスまたはパスワードが違います。";
                            console.error("Login error:", error);
                        });
                } else {
                    const confirmPassword = confirmPasswordInput.value.trim();
                    if (password !== confirmPassword) {
                        authError.textContent = 'パスワードが一致しません。';
                        return;
                    }
                    createUserWithEmailAndPassword(auth, email, password)
                        .then(async (userCredential) => {
                            const user = userCredential.user;
                            await updateProfile(user, { displayName });
                            await setDoc(doc(db, "users", user.uid), {
                                displayName: displayName,
                                email: user.email,
                                photoURL: null, // Initialize photoURL
                            });
                            showInfoModal('アカウントを作成しました！ログインしてください。');
                            toggleAuthMode();
                        })
                        .catch(error => {
                            if (error.code === 'auth/email-already-in-use') {
                                authError.textContent = "このメールアドレスは既に使用されています。";
                            } else {
                                authError.textContent = "アカウント作成に失敗しました。";
                            }
                            console.error("Signup error:", error);
                        });
                }
            }
            
            function handleGuestLogin() {
                signInAnonymously(auth).catch(error => {
                    authError.textContent = "ゲストログインに失敗しました。";
                    console.error("Anonymous sign-in error:", error);
                });
            }

            function toggleAuthMode() {
                isLoginMode = !isLoginMode;
                authError.textContent = '';
                displayNameInput.value = '';
                emailInput.value = '';
                passwordInput.value = '';
                confirmPasswordInput.value = '';
                if (isLoginMode) {
                    authTitle.textContent = 'ログイン';
                    authBtn.textContent = 'ログイン';
                    displayNameInput.classList.add('hidden');
                    confirmPasswordWrapper.classList.add('hidden');
                    authSwitchText.textContent = 'アカウントをお持ちでないですか？';
                    authSwitchLink.textContent = '新規登録はこちら';
                } else {
                    authTitle.textContent = '新規登録';
                    authBtn.textContent = '登録する';
                    displayNameInput.classList.remove('hidden');
                    confirmPasswordWrapper.classList.remove('hidden');
                    authSwitchText.textContent = 'すでにアカウントをお持ちですか？';
                    authSwitchLink.textContent = 'ログインはこちら';
                }
            }

            function handleLogout() {
                signOut(auth).then(() => {
                    location.reload();
                });
            }

            async function initAppForUser(user) {
                await user.getIdToken(true);
                
                userDisplay.innerHTML = ''; // Clear previous user info

                const userDocRef = doc(db, "users", user.uid);
                const userDocSnap = await getDoc(userDocRef);
                const userData = userDocSnap.exists() ? userDocSnap.data() : {};

                const photoURL = userData.photoURL || user.photoURL || 'https://placehold.co/40x40/D35400/FFF?text=�';
                
                const icon = document.createElement('img');
                icon.src = photoURL;
                icon.alt = 'プロフィールアイコン';
                icon.className = 'profile-icon';
                
                const nameContainer = document.createElement('div');
                nameContainer.className = 'flex flex-col items-start';

                const nameEl = document.createElement('span');
                nameEl.className = 'text-sm font-semibold text-gray-700';
                nameEl.textContent = user.isAnonymous ? 'ゲスト' : (userData.displayName || user.displayName || '名無しさん');
                
                nameContainer.appendChild(nameEl);
                userDisplay.appendChild(icon);
                userDisplay.appendChild(nameContainer);

                user.getIdTokenResult()
                    .then(async (idTokenResult) => {
                        const isAdmin = !!idTokenResult.claims.admin;
                        
                        const roleBadge = document.createElement('span');
                        roleBadge.className = 'role-badge';
                        if (isAdmin) {
                            roleBadge.textContent = '管理者';
                            roleBadge.classList.add('bg-purple-200', 'text-purple-800');
                            adminControls.classList.remove('hidden');
                            
                            const usersCol = collection(db, 'users');
                            const userSnapshot = await getDocs(usersCol);
                            userSwitcher.innerHTML = '<option value="">他のユーザーのプランを見る</option>';
                            userSnapshot.forEach(doc => {
                                const uData = doc.data();
                                const option = document.createElement('option');
                                option.value = doc.id;
                                option.textContent = uData.displayName || uData.email || doc.id;
                                userSwitcher.appendChild(option);
                            });
                            listenForSubmissions();
                            listenForImageReports();
                        } else {
                            roleBadge.textContent = '一般';
                            roleBadge.classList.add('bg-green-200', 'text-green-800');
                            adminControls.classList.add('hidden');
                        }
                        nameContainer.appendChild(roleBadge);
                    })
                    .catch((error) => {
                        console.log("カスタムクレームの確認中にエラー（一般ユーザーの場合は正常）:", error.message);
                        adminControls.classList.add('hidden');
                    });
                
                if (unsubscribeMailbox) unsubscribeMailbox();
                if (unsubscribeAnnouncements) unsubscribeAnnouncements();
                
                let personalNotifications = [];
                
                const updateAndRenderMailbox = () => {
                    const allNotifications = [...personalNotifications, ...localAnnouncements];
                    allNotifications.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));

                    let unreadCount = 0;
                    const lastReadTimestamp = parseInt(localStorage.getItem('lastReadAnnouncementTimestamp') || '0', 10);

                    personalNotifications.forEach(n => {
                        if (!n.read) unreadCount++;
                    });
                    
                    localAnnouncements.forEach(n => {
                        if (n.createdAt && n.createdAt.toMillis() > lastReadTimestamp) {
                            unreadCount++;
                        }
                    });

                    mailboxBadge.textContent = unreadCount;
                    mailboxBadge.classList.toggle('hidden', unreadCount === 0);
                    renderMailbox(allNotifications, lastReadTimestamp);
                };
                
                if (!user.isAnonymous) {
                    const mailboxQuery = query(collection(db, "users", user.uid, "mailbox"));
                    unsubscribeMailbox = onSnapshot(mailboxQuery, (snapshot) => {
                        personalNotifications = snapshot.docs.map(d => ({...d.data(), id: d.id, type: 'personal'}));
                        updateAndRenderMailbox();
                    });
                } else {
                     mailboxBtn.classList.add('hidden');
                }

                const announcementsQuery = query(collection(db, "announcements"));
                unsubscribeAnnouncements = onSnapshot(announcementsQuery, (snapshot) => {
                    localAnnouncements = snapshot.docs.map(d => ({...d.data(), id: d.id, type: 'public'}));
                    updateAndRenderMailbox();
                });

                viewUserPlan(user.uid, user.displayName || 'ゲスト');
            }

            async function viewUserPlan(userId, userName) {
                if (unsubscribePlan) unsubscribePlan();
                if (unsubscribeFavorites) unsubscribeFavorites();

                viewedUserId = userId;
                
                const isViewingOwnPlan = currentUser.uid === viewedUserId;
                myPlanTitle.textContent = isViewingOwnPlan ? 'マイプラン' : `${userName}のプラン`;
                planControls.style.display = isViewingOwnPlan ? 'block' : 'none';

                const planDocRef = doc(db, "plans", viewedUserId);
                unsubscribePlan = onSnapshot(planDocRef, (docSnap) => {
                    localPlan = docSnap.exists() ? docSnap.data().spots || [] : [];
                    renderAll();
                }, (error) => {
                    console.error("プランの読み込みエラー:", error);
                    if (error.code === 'permission-denied') {
                         planItemsList.innerHTML = `<p class="text-red-500 text-center py-10">このユーザーのプランを閲覧する権限がありません。</p>`;
                    }
                });

                const favDocRef = doc(db, "favorites", viewedUserId);
                unsubscribeFavorites = onSnapshot(favDocRef, (docSnap) => {
                    localFavorites = docSnap.exists() ? docSnap.data().spots || [] : [];
                    renderAll();
                }, (error) => {
                    console.error("お気に入りの読み込みエラー:", error);
                    localFavorites = [];
                    renderAll();
                });
            }
            
            async function toggleFavorite(spotName) {
                if (!currentUser || currentUser.uid !== viewedUserId) {
                    showInfoModal("他のユーザーのお気に入りは変更できません。");
                    return;
                };

                const favDocRef = doc(db, "favorites", currentUser.uid);
                const newFavorites = localFavorites.includes(spotName)
                    ? localFavorites.filter(name => name !== spotName)
                    : [...localFavorites, spotName];
                await setDoc(favDocRef, { spots: newFavorites }, { merge: true });
            }
            
            async function _addSpotToPlan(spotName) {
                if (!currentUser || viewedUserId !== currentUser.uid) return;
                if (localPlan.includes(spotName)) return;
                const planDocRef = doc(db, "plans", currentUser.uid);
                const newPlan = [...localPlan, spotName];
                await setDoc(planDocRef, { spots: newPlan }, { merge: true });
            }

            async function addToPlan(spotName) {
                if (!currentUser || viewedUserId !== currentUser.uid) {
                    showInfoModal("他のユーザーのプランには追加できません。");
                    return;
                }
                if (localPlan.includes(spotName)) return;

                const spotToAdd = combinedSpots.find(s => s.name === spotName);

                if (!spotToAdd) return;

                if (localPlan.length > 0) {
                    const firstSpotInPlan = combinedSpots.find(s => s.name === localPlan[0]);
                    if (firstSpotInPlan && firstSpotInPlan.prefecture !== spotToAdd.prefecture) {
                        showCrossPrefectureConfirmation(spotToAdd, firstSpotInPlan);
                    } else {
                        _addSpotToPlan(spotName);
                    }
                } else {
                    _addSpotToPlan(spotName);
                }
            };

            async function removeFromPlan(spotName) {
                if (!currentUser || viewedUserId !== currentUser.uid) return;
                const planDocRef = doc(db, "plans", currentUser.uid);
                const newPlan = localPlan.filter(name => name !== spotName);
                await setDoc(planDocRef, { spots: newPlan });
            };
            
            async function savePlanOrder(newPlanOrder) {
                if (!currentUser || viewedUserId !== currentUser.uid) return;
                const planDocRef = doc(db, "plans", currentUser.uid);
                await setDoc(planDocRef, { spots: newPlanOrder });
            }

            async function clearPlan() {
                if (!currentUser || viewedUserId !== currentUser.uid) return;
                const planDocRef = doc(db, "plans", currentUser.uid);
                await setDoc(planDocRef, { spots: [] });
            }

            function createCard(spot) {
                const card = document.createElement('div');
                card.className = 'card bg-white rounded-xl shadow-md overflow-hidden flex flex-col relative';
                
                const isFavorited = localFavorites.includes(spot.name);
                const isInPlan = localPlan.includes(spot.name);
                
                card.innerHTML = `
                    <div class="favorite-btn ${isFavorited ? 'favorited' : ''}" title="お気に入りに追加">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                    </div>
                    <div class="card-content p-5 pt-3 flex flex-col flex-grow">
                        <div class="flex-grow">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="inline-block px-3 py-1 text-xs font-semibold rounded-full ${spot.category === '観光' ? 'bg-blue-100 text-blue-800' : 'bg-pink-100 text-pink-800'}">${spot.category}</span>
                                <span class="inline-block px-3 py-1 text-xs font-semibold rounded-full bg-gray-100 text-gray-800">${spot.subCategory}</span>
                            </div>
                            <p class="text-sm font-semibold text-gray-500 mb-1">${spot.prefecture}・${spot.area}</p>
                            <h3 class="text-xl font-bold text-gray-800 mb-2">${spot.name}</h3>
                            <div class="flex flex-wrap gap-1 mb-3">
                                ${spot.tags ? spot.tags.map(tag => `<span class="text-xs bg-teal-100 text-teal-800 px-2 py-0.5 rounded-full">#${tag}</span>`).join('') : ''}
                            </div>
                            <p class="text-gray-600 text-sm line-clamp-3">${spot.description}</p>
                        </div>
                        <div class="mt-4 flex-shrink-0">
                            <button class="add-to-plan-btn w-full py-2 px-4 rounded-lg font-semibold text-sm transition-colors duration-200 ${isInPlan ? 'bg-gray-300 text-gray-500 cursor-not-allowed' : 'bg-orange-500 text-white hover:bg-orange-600'}">
                                ${isInPlan ? '✓ プランに追加済み' : '+ プランに追加'}
                            </button>
                        </div>
                    </div>
                `;
                
                card.addEventListener('click', (e) => {
                    if (e.target.closest('.favorite-btn') || e.target.closest('.add-to-plan-btn')) {
                        return;
                    }
                    openModal(spot);
                });

                card.querySelector('.favorite-btn').addEventListener('click', () => toggleFavorite(spot.name));
                
                const addToPlanBtn = card.querySelector('.add-to-plan-btn');
                if (!isInPlan) {
                    addToPlanBtn.addEventListener('click', () => addToPlan(spot.name));
                }
                
                return card;
            }
            
            function renderSpots() {
                spotsList.innerHTML = '';
                let sourceSpots = combinedSpots;

                // 1. Prefecture Filter
                if (currentPrefecture !== 'all') {
                    const selectedPrefectureName = prefectureFilter.options[prefectureFilter.selectedIndex].text;
                    sourceSpots = sourceSpots.filter(spot => spot.prefecture === selectedPrefectureName);
                }
                
                // 2. Category Filter (for 'favorites')
                if (currentFilters.category === 'favorites') {
                    sourceSpots = sourceSpots.filter(spot => localFavorites.includes(spot.name));
                }

                // 3. Main Filters (Category, Area, Tag)
                let filteredSpots = sourceSpots.filter(spot => {
                    const categoryMatch = currentFilters.category === 'all' || currentFilters.category === 'favorites' || spot.category === currentFilters.category;
                    const areaMatch = currentFilters.area === 'all' || spot.area === currentFilters.area;
                    const tagMatch = currentFilters.tag === 'all' || (spot.tags && spot.tags.includes(currentFilters.tag));
                    return categoryMatch && areaMatch && tagMatch;
                });

                // 4. Search Filter
                if (currentSearchTerm) {
                    filteredSpots = filteredSpots.filter(spot => 
                        spot.name.toLowerCase().includes(currentSearchTerm)
                    );
                }

                // 5. Sorting
                // Note: The base order is oldest first because new spots are pushed to the end of the JSON.
                switch (currentSortOrder) {
                    case 'name-asc':
                        filteredSpots.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
                        break;
                    case 'name-desc':
                        filteredSpots.sort((a, b) => b.name.localeCompare(a.name, 'ja'));
                        break;
                    case 'default': // Newest first
                        filteredSpots.reverse(); // Reverse the oldest-first array
                        break;
                    case 'default-desc': // Oldest first
                    default:
                        // Do nothing, the natural order is already oldest first.
                        break;
                }

                // 6. Render
                if (filteredSpots.length > 0) {
                    filteredSpots.forEach(spot => spotsList.appendChild(createCard(spot)));
                } else {
                    spotsList.innerHTML = `<p class="col-span-full text-center text-gray-500 py-10">該当するスポットはありません。</p>`;
                }
                updateListTitle();
            }

            function updateListTitle() {
                let titleText = '';
                if (currentFilters.area !== 'all') titleText += `${currentFilters.area}の`;
                
                if (currentFilters.category === 'favorites') titleText += 'お気に入り';
                else if (currentFilters.category !== 'all') titleText += `${currentFilters.category}`;
                else titleText += 'すべての';

                if (currentFilters.tag !== 'all') titleText += ` #${currentFilters.tag}`;

                titleText += 'スポット';
                listTitle.textContent = titleText;
            }

            function renderAreaMap() {
                const positions = areaPositions[currentPrefecture];
                mapContainer.innerHTML = '';

                if (!positions || positions.length === 0) {
                    mapContainer.innerHTML = `<p class="text-center text-gray-500 py-10">この都道府県のエリアマップは<br>現在準備中です。</p>`;
                    return;
                }

                // 線の描画（省略）

                // 「全エリア」ボタンを右下（90%, 90%）に配置
                const allBtn = document.createElement('button');
                allBtn.dataset.area = 'all';
                allBtn.textContent = '全エリア';
                allBtn.className = `map-area-button ${currentPrefecture}`;
                allBtn.style.top = '90%';   // ここを変更
                allBtn.style.left = '90%';  // ここを変更
                if (currentFilters.area === 'all') allBtn.classList.add('active');
                mapContainer.appendChild(allBtn);

                positions.forEach(area => {
                    const button = document.createElement('button');
                    button.dataset.area = area.name;
                    button.textContent = area.name;
                    button.className = `map-area-button ${currentPrefecture}`;
                    button.style.top = area.top;
                    button.style.left = area.left;
                    if (currentFilters.area === area.name) button.classList.add('active');
                    mapContainer.appendChild(button);
                });
            }

            function renderAreaList() {
                const positions = areaPositions[currentPrefecture];
                areaListContainer.innerHTML = '';

                if (!positions || positions.length === 0) {
                    areaListContainer.innerHTML = `<p class="text-center text-gray-500 py-10">この都道府県のエリアリストは<br>現在準備中です。</p>`;
                    return;
                }

                const allBtn = document.createElement('button');
                allBtn.dataset.area = 'all';
                allBtn.textContent = '全エリア';
                allBtn.className = 'tag-btn';
                if (currentFilters.area === 'all') allBtn.classList.add('active');
                areaListContainer.appendChild(allBtn);

                positions.forEach(area => {
                    const button = document.createElement('button');
                    button.dataset.area = area.name;
                    button.textContent = area.name;
                    button.className = 'tag-btn';
                    if (currentFilters.area === area.name) button.classList.add('active');
                    areaListContainer.appendChild(button);
                });
            }

            function renderAreaFilterContent() {
                areaViewSwitcher.querySelectorAll('button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.view === areaFilterView);
                });

                if (areaFilterView === 'map') {
                    mapContainer.classList.remove('hidden');
                    areaListContainer.classList.add('hidden');
                    renderAreaMap();
                } else { // 'list'
                    mapContainer.classList.add('hidden');
                    areaListContainer.classList.remove('hidden');
                    renderAreaList();
                }
            }

            function renderTags() {
                tagFilters.innerHTML = `<button data-filter="all" class="tag-btn">すべてのタグ</button>`;
                standardTags.forEach(tag => {
                    const button = document.createElement('button');
                    button.dataset.filter = tag;
                    button.textContent = `#${tag}`;
                    button.className = 'tag-btn';
                    if (currentFilters.tag === tag) button.classList.add('active');
                    tagFilters.appendChild(button);
                });
            }

            function getTransitTime(area1, area2, prefecture) {
                if (area1 === area2) return 0;
                const transitMatrix = allTransitData[prefecture];
                if (!transitMatrix) return null; // Prefecture data might not exist

                if (transitMatrix[area1] && transitMatrix[area1][area2] !== undefined) {
                    return transitMatrix[area1][area2];
                }
                if (transitMatrix[area2] && transitMatrix[area2][area1] !== undefined) {
                    return transitMatrix[area2][area1];
                }
                return null; // Return null if specific path is not defined
            }

            function parseStayTime(timeString) {
                if (!timeString) return 0;
                
                if (timeString.includes('1日')) {
                    return 8 * 60; // 8 hours for a full day
                }

                const numbers = timeString.match(/\d+/g)?.map(Number) || [];
                if (numbers.length === 0) return 0;
                
                let totalMinutes = 0;
                if (timeString.includes('時間')) {
                    totalMinutes = numbers[0] * 60;
                    if (numbers.length > 1 && timeString.includes('分')) {
                        totalMinutes += numbers[1];
                    }
                } else if (timeString.includes('-')) {
                    totalMinutes = (numbers[0] + numbers[1]) / 2;
                } else if (timeString.includes('分')) {
                    totalMinutes = numbers[0];
                }
                return totalMinutes;
            }

            function generateGoogleMapsRouteUrl() {
                const plan = localPlan;

                if (plan.length === 1) {
                    const spot = combinedSpots.find(s => s.name === plan[0]);
                    return spot ? spot.gmaps : '#';
                }
                
                if (plan.length < 2) return '#';

                const baseUrl = 'https://www.google.com/maps/dir/';
                const waypoints = plan.map(spotName => {
                    const spot = combinedSpots.find(s => s.name === spotName);
                    if (!spot) return null;
                    try {
                        const url = new URL(spot.gmaps);
                        const query = url.searchParams.get('query');
                        return encodeURIComponent(query || spot.name);
                    } catch (e) {
                        return encodeURIComponent(spot.name);
                    }
                }).filter(Boolean);

                return baseUrl + waypoints.join('/');
            }

            function renderPlan() {
                const plan = localPlan;
                planItemsList.innerHTML = '';
                let totalMinutes = 0;
                const isViewingOwnPlan = currentUser && currentUser.uid === viewedUserId;

                if (plan.length === 0) {
                    planItemsList.innerHTML = `<p class="text-gray-500 text-center py-10">${isViewingOwnPlan ? 'プランは空です。<br>気になるスポットを追加してみましょう！' : 'このユーザーのプランは空です。'}</p>`;
                } else {
                    plan.forEach((spotName, index) => {
                        const spot = combinedSpots.find(s => s.name === spotName);
                        if (!spot) return;
                        
                        totalMinutes += parseStayTime(spot.stayTime);
                        
                        const item = document.createElement('div');
                        item.className = 'plan-item flex items-center bg-gray-50 p-3 rounded-lg shadow-sm';
                        item.dataset.spotName = spot.name;
                        
                        item.innerHTML = `
                            <span class="move-handle text-gray-400" ${isViewingOwnPlan ? 'draggable="true"': ''}>☰</span>
                            <div class="flex-grow ml-2">
                                <p class="font-bold text-gray-800">${spot.name}</p>
                                <p class="text-sm text-gray-500">${spot.area} | ${spot.stayTime}</p>
                            </div>
                            <button class="remove-from-plan-btn text-red-500 hover:text-red-700 ml-4 p-1 rounded-full ${isViewingOwnPlan ? '' : 'hidden'}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>
                            </button>
                        `;
                        planItemsList.appendChild(item);
                        if (isViewingOwnPlan) {
                           item.querySelector('.remove-from-plan-btn').addEventListener('click', () => removeFromPlan(spot.name));
                        }

                        if (index < plan.length - 1) {
                            const nextSpotName = plan[index + 1];
                            const nextSpot = combinedSpots.find(s => s.name === nextSpotName);
                            const transitEl = document.createElement('div');
                            transitEl.className = 'transit-time';

                            if (nextSpot && spot.prefecture === nextSpot.prefecture) {
                                const transitTime = getTransitTime(spot.area, nextSpot.area, spot.prefecture.replace(/[都府県]/, ''));
                                if (transitTime !== null) {
                                    totalMinutes += transitTime;
                                    transitEl.innerHTML = `
                                        <div class="transit-time-icon">
                                            <svg class="w-5 h-5 text-gray-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v1.333a1 1 0 01-1.333 1.334h-1.334A2.667 2.667 0 006 8v5.333a2.667 2.667 0 002.667 2.667h1.334a1.333 1.333 0 110 2.666H8A5.333 5.333 0 012.667 13.333V8a5.333 5.333 0 015.333-5.333h.001zm4.667 1.333a1 1 0 10-1.334-1.333A2.667 2.667 0 0010.667 4v1.333a2.667 2.667 0 002.666 2.667h1.334a1.333 1.333 0 100-2.667h-1.334A1 1 0 0114.667 4.333z" clip-rule="evenodd" /></svg>
                                        </div>
                                        <span class="text-sm font-semibold text-gray-600">移動: 約${transitTime}分</span>
                                    `;
                                } else {
                                    transitEl.innerHTML = `
                                        <div class="transit-time-icon">
                                            <svg class="w-5 h-5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                                        </div>
                                        <span class="text-xs font-semibold text-yellow-600">エリア間の移動時間は未設定です</span>
                                    `;
                                }
                            } else {
                                 transitEl.innerHTML = `
                                    <div class="transit-time-icon">
                                        <svg class="w-5 h-5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                                    </div>
                                    <span class="text-xs font-semibold text-yellow-600">他県のため移動時間は計算されません</span>
                                 `;
                            }
                            planItemsList.appendChild(transitEl);
                        }
                    });
                }
                
                planCountBadge.textContent = plan.length;
                planCountBadge.classList.toggle('hidden', plan.length === 0);

                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                planTotalTimeEl.textContent = `${hours > 0 ? hours + '時間' : ''} ${minutes}分`;

                const mapButtonsEnabled = plan.length > 0;
                routeMapBtn.classList.toggle('opacity-50', !mapButtonsEnabled);
                routeMapBtn.classList.toggle('cursor-not-allowed', !mapButtonsEnabled);
                routeMapFromCurrentBtn.classList.toggle('opacity-50', !mapButtonsEnabled);
                routeMapFromCurrentBtn.classList.toggle('cursor-not-allowed', !mapButtonsEnabled);

                if (mapButtonsEnabled) {
                    routeMapBtn.href = generateGoogleMapsRouteUrl();
                } else {
                    routeMapBtn.href = '#';
                }
            }

            let draggedItem = null;
            
            function handleDragStart(e) {
                if (!e.target.classList.contains('move-handle')) {
                    e.preventDefault();
                    return;
                }
                draggedItem = e.target.closest('.plan-item');
                setTimeout(() => {
                    if(draggedItem) draggedItem.classList.add('dragging');
                }, 0);
            }

            function handleDragOver(e) {
                if (viewedUserId !== currentUser.uid) return;
                e.preventDefault();
                const afterElement = getDragAfterElement(planItemsList, e.clientY);
                const currentDragged = document.querySelector('.dragging');
                if (!currentDragged) return;
                if (afterElement == null) {
                    planItemsList.appendChild(currentDragged);
                } else {
                    planItemsList.insertBefore(currentDragged, afterElement);
                }
            }
            
            function handleDrop(e) {
                e.preventDefault();
                if (!draggedItem) return;
                draggedItem.classList.remove('dragging');
                const newPlanOrder = [...planItemsList.querySelectorAll('.plan-item')].map(item => item.dataset.spotName);
                
                localPlan = newPlanOrder;
                renderPlan(); // Re-render to update transit times correctly
                
                savePlanOrder(newPlanOrder);
                draggedItem = null;
            }

            function handleTouchStart(e) {
                if (viewedUserId !== currentUser.uid || !e.target.classList.contains('move-handle')) {
                    return;
                }
                e.preventDefault();
                draggedItem = e.target.closest('.plan-item');
                if (draggedItem) {
                    draggedItem.classList.add('dragging');
                }
            }

            function handleTouchMove(e) {
                if (!draggedItem) return;
                e.preventDefault();
                const touch = e.touches[0];
                const afterElement = getDragAfterElement(planItemsList, touch.clientY);
                if (afterElement == null) {
                    planItemsList.appendChild(draggedItem);
                } else {
                    planItemsList.insertBefore(draggedItem, afterElement);
                }
            }

            function handleTouchEnd(e) {
                if (!draggedItem) return;
                draggedItem.classList.remove('dragging');
                const newPlanOrder = [...planItemsList.querySelectorAll('.plan-item')].map(item => item.dataset.spotName);
                
                localPlan = newPlanOrder;
                renderPlan();

                savePlanOrder(newPlanOrder);
                draggedItem = null;
            }

            planItemsList.addEventListener('dragstart', handleDragStart);
            planItemsList.addEventListener('dragover', handleDragOver);
            planItemsList.addEventListener('drop', handleDrop);
            planItemsList.addEventListener('dragend', (e) => {
                if (draggedItem) {
                    draggedItem.classList.remove('dragging');
                }
                draggedItem = null;
            });
            planItemsList.addEventListener('touchstart', handleTouchStart, { passive: false });
            planItemsList.addEventListener('touchmove', handleTouchMove, { passive: false });
            planItemsList.addEventListener('touchend', handleTouchEnd);


            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.plan-item:not(.dragging)')];
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            async function openModal(spot) {
                modal.dataset.spotName = spot.name;
                document.getElementById('modal-title').textContent = spot.name;
                document.getElementById('modal-description').innerHTML = spot.description;
                document.getElementById('modal-stay-time').textContent = `平均滞在時間: ${spot.stayTime}`;
                const modalImage = document.getElementById('modal-image');
                const modalImageSource = document.getElementById('modal-image-source');

                modalImage.src = spot.image || 'https://placehold.co/600x400/E57373/FFF?text=Image+Not+Found';
                
                if (spot.imageSourceUrl && spot.imageSource) {
                    modalImageSource.href = spot.imageSourceUrl;
                    modalImageSource.textContent = `画像引用元: ${spot.imageSource}`;
                    modalImageSource.classList.remove('hidden');
                } else {
                    modalImageSource.classList.add('hidden');
                }

                modalImage.onload = () => {
                    modalImageSpinner.classList.add('hidden');
                    modalImage.classList.remove('hidden');
                };
                modalImage.onerror = () => {
                    modalImage.src = 'https://placehold.co/600x400/E57373/FFF?text=Image+Not+Found';
                    modalImageSpinner.classList.add('hidden');
                    modalImage.classList.remove('hidden');
                };

                const modalTagsContainer = document.getElementById('modal-tags');
                modalTagsContainer.innerHTML = '';
                 if (spot.tags) {
                        spot.tags.forEach(tag => {
                            const tagEl = document.createElement('span');
                            tagEl.className = 'text-sm bg-teal-100 text-teal-800 px-3 py-1 rounded-full';
                            tagEl.textContent = `#${tag}`;
                            modalTagsContainer.appendChild(tagEl);
                        });
               }

                const modalWebsite = document.getElementById('modal-website');
                const modalMap = document.getElementById('modal-map');
                modalMap.href = spot.gmaps;

                if (spot.website && spot.website !== '#') {
                    modalWebsite.href = spot.website;
                    modalWebsite.classList.remove('hidden');
                } else {
                    modalWebsite.classList.add('hidden');
                }

                showOverlay(modal);
            }
            
            function closeModal() {
                hideOverlay(modal);
            }

            function showConfirmationModal(message, actionButtonText, buttonClass, onConfirm) {
                confirmationMessage.innerHTML = message.replace(/\n/g, '<br>'); // Support newlines
                confirmActionBtn.textContent = actionButtonText;

                confirmActionBtn.className = `py-2 px-6 text-white rounded-lg font-semibold transition-colors ${buttonClass} hover:${buttonClass.replace('500', '600')}`;

                showOverlay(confirmationOverlay);

                confirmActionBtn.onclick = () => {
                    onConfirm();
                    hideOverlay(confirmationOverlay);
                };
            }

            function showCrossPrefectureConfirmation(spotToAdd, firstSpotInPlan) {
                crossPrefectureMessage.innerHTML = `「${firstSpotInPlan.prefecture}」のプランに「${spotToAdd.prefecture}」のスポットを追加しようとしています。<br>移動時間が正しく計算されませんが、よろしいですか？`;
                showOverlay(crossPrefectureOverlay);

                const closeOverlay = () => {
                    hideOverlay(crossPrefectureOverlay);
                    crossPrefectureAddBtn.onclick = null;
                    crossPrefectureFavoriteBtn.onclick = null;
                    crossPrefectureCancelBtn.onclick = null;
                }

                crossPrefectureAddBtn.onclick = () => {
                    _addSpotToPlan(spotToAdd.name);
                    closeOverlay();
                };
                crossPrefectureFavoriteBtn.onclick = () => {
                    toggleFavorite(spotToAdd.name);
                    showInfoModal(`「${spotToAdd.name}」をお気に入りに追加しました。`);
                    closeOverlay();
                };
                crossPrefectureCancelBtn.onclick = closeOverlay;
            }

            authBtn.addEventListener('click', handleAuth);
            guestLoginBtn.addEventListener('click', handleGuestLogin);
            emailInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') authBtn.click(); });
            passwordInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') authBtn.click(); });
            confirmPasswordInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') authBtn.click(); });
            authSwitchLink.addEventListener('click', (e) => { e.preventDefault(); toggleAuthMode(); });
            logoutBtnSettings.addEventListener('click', handleLogout);

            prefectureFilter.addEventListener('change', (e) => {
                currentPrefecture = e.target.value;
                currentFilters.area = 'all'; 
                
                if (currentPrefecture === 'all' || !areaPositions[currentPrefecture] || areaPositions[currentPrefecture].length === 0) {
                    openAreaFilterBtn.disabled = true;
                } else {
                    openAreaFilterBtn.disabled = false;
                }
                
                renderSpots();
            });

            categoryFilters.addEventListener('click', (e) => {
                const button = e.target.closest('.filter-btn');
                if (button) {
                    currentFilters.category = button.dataset.filter;
                    categoryFilters.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active-filter'));
                    button.classList.add('active-filter');
                    renderSpots();
                }
            });
            
            openAreaFilterBtn.addEventListener('click', () => {
                renderAreaFilterContent();
                showOverlay(areaFilterOverlay);
            });
            closeAreaFilterBtn.addEventListener('click', () => hideOverlay(areaFilterOverlay));
            
            areaViewSwitcher.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && button.dataset.view) {
                    areaFilterView = button.dataset.view;
                    renderAreaFilterContent();
                }
            });

            areaListContainer.addEventListener('click', (e) => {
                const button = e.target.closest('.tag-btn');
                if (button) {
                    currentFilters.area = button.dataset.area;
                    renderSpots();
                    hideOverlay(areaFilterOverlay);
                }
            });

            mapContainer.addEventListener('click', (e) => {
                const button = e.target.closest('.map-area-button');
                if (button) {
                    currentFilters.area = button.dataset.area;
                    renderSpots();
                    hideOverlay(areaFilterOverlay);
                }
            });
            
            openTagFilterBtn.addEventListener('click', () => {
                renderTags();
                showOverlay(tagFilterOverlay);
            });
            closeTagFilterBtn.addEventListener('click', () => hideOverlay(tagFilterOverlay));

            tagFilters.addEventListener('click', (e) => {
                const button = e.target.closest('.tag-btn');
                if (button) {
                    currentFilters.tag = button.dataset.filter;
                    renderSpots();
                    hideOverlay(tagFilterOverlay);
                }
            });

            modalClose.addEventListener('click', closeModal);
            modal.addEventListener('click', (e) => { if(e.target === modal) closeModal(); });
            
            myPlanBtn.addEventListener('click', () => {
                myPlanPanelOverlay.classList.remove('hidden');
                myPlanPanel.classList.remove('translate-x-full');
                toggleBodyScroll(true);
            });
            const closePlanPanel = () => {
                myPlanPanel.classList.add('translate-x-full');
                myPlanPanelOverlay.classList.add('hidden');
                toggleBodyScroll(false);
            };
            myPlanCloseBtn.addEventListener('click', closePlanPanel);
            myPlanPanelOverlay.addEventListener('click', closePlanPanel);

            clearPlanBtn.addEventListener('click', () => {
                showConfirmationModal('本当にすべてのプランを削除しますか？', '削除', 'bg-red-500', clearPlan);
            });

            confirmCancelBtn.addEventListener('click', () => hideOverlay(confirmationOverlay));
            confirmationOverlay.addEventListener('click', (e) => {
                if (e.target === confirmationOverlay) hideOverlay(confirmationOverlay);
            });

            copyPlanBtn.addEventListener('click', () => {
                const plan = localPlan;
                if (plan.length === 0) return;

                let planText = `【${currentUser.isAnonymous ? 'ゲスト' : currentUser.displayName}さんのVLOG旅プラン】\n`;
                let totalMinutes = 0;
                
                plan.forEach((spotName, index) => {
                    const spot = combinedSpots.find(s => s.name === spotName);
                    if (!spot) return;

                    const stayTime = parseStayTime(spot.stayTime);
                    totalMinutes += stayTime;
                    planText += `\n📍 ${index + 1}. ${spot.name}\n`;
                    planText += `   (滞在: ${spot.stayTime})\n`;

                    if (index < plan.length - 1) {
                        const nextSpot = combinedSpots.find(s => s.name === plan[index + 1]);
                        if (nextSpot && spot.prefecture === nextSpot.prefecture) {
                            const transitTime = getTransitTime(spot.area, nextSpot.area, spot.prefecture.replace(/[都府県]/, ''));
                            if (transitTime !== null) {
                                totalMinutes += transitTime;
                                planText += `   ⬇️\n   (移動: 約${transitTime}分)\n`;
                            } else {
                                planText += `   ⬇️\n   (移動: 時間未設定)\n`;
                            }
                        } else {
                            planText += `   ⬇️\n   (他県への移動)\n`;
                        }
                    }
                });

                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                const totalTimeText = `${hours > 0 ? hours + '時間' : ''}${minutes}分`;

                planText += `\n--------------------\n`;
                planText += `合計目安時間: ${totalTimeText} (移動時間込み)`;

                copyTextarea.value = planText;
                copyTextarea.select();
                document.execCommand('copy');

                const originalText = copyPlanBtn.textContent;
                copyPlanBtn.textContent = 'コピーしました！';
                copyPlanBtn.classList.add('bg-green-500', 'hover:bg-green-600');
                copyPlanBtn.classList.remove('bg-teal-500', 'hover:bg-teal-600');
                
                setTimeout(() => {
                    copyPlanBtn.textContent = originalText;
                    copyPlanBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    copyPlanBtn.classList.add('bg-teal-500', 'hover:bg-teal-600');
                }, 2000);
            });
            
            routeMapFromCurrentBtn.addEventListener('click', () => {
                if (localPlan.length === 0) {
                    showInfoModal("プランにスポットがありません。");
                    return;
                }
                if (!navigator.geolocation) {
                    showInfoModal("お使いのブラウザは位置情報機能に対応していません。");
                    return;
                }

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        const baseUrl = 'https://www.google.com/maps/dir/';
                        const origin = `${latitude},${longitude}`;
                        const waypoints = localPlan.map(spotName => {
                            const spot = combinedSpots.find(s => s.name === spotName);
                            if (!spot) return null;
                            try {
                                const url = new URL(spot.gmaps);
                                return encodeURIComponent(url.searchParams.get('query') || spot.name);
                            } catch (e) {
                                return encodeURIComponent(spot.name);
                            }
                        }).filter(Boolean);

                        const finalUrl = baseUrl + origin + '/' + waypoints.join('/');
                        window.open(finalUrl, '_blank');
                    },
                    (error) => {
                        showInfoModal("位置情報を取得できませんでした。ブラウザの設定を確認してください。");
                        console.error("Geolocation error:", error);
                    }
                );
            });

            const eyeIcon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`;
            const eyeSlashIcon = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>`;
            
            passwordToggle.innerHTML = eyeIcon;
            confirmPasswordToggle.innerHTML = eyeIcon;

            function setupPasswordToggle(toggleBtn, inputEl) {
                 toggleBtn.addEventListener('click', () => {
                     const type = inputEl.getAttribute('type') === 'password' ? 'text' : 'password';
                     inputEl.setAttribute('type', type);
                     toggleBtn.innerHTML = type === 'password' ? eyeIcon : eyeSlashIcon;
                 });
            }
            
            setupPasswordToggle(passwordToggle, passwordInput);
            setupPasswordToggle(confirmPasswordToggle, confirmPasswordInput);

            userSettingsBtn.addEventListener('click', async () => {
                if (!currentUser) return;
                
                if (currentUser.isAnonymous) {
                    settingsIconSection.classList.add('hidden');
                    settingsUsernameSection.classList.add('hidden');
                    settingsEmailSection.classList.add('hidden');
                    saveSettingsBtn.classList.add('hidden');
                } else {
                    const userDocRef = doc(db, "users", currentUser.uid);
                    const userDocSnap = await getDoc(userDocRef);
                    const userData = userDocSnap.exists() ? userDocSnap.data() : {};

                    settingsIconSection.classList.remove('hidden');
                    settingsUsernameSection.classList.remove('hidden');
                    settingsEmailSection.classList.remove('hidden');
                    saveSettingsBtn.classList.remove('hidden');

                    settingsUsernameInput.value = currentUser.displayName || '';
                    settingsEmail.textContent = currentUser.email || 'N/A';
                    settingsIconPreview.src = currentUser.photoURL || 'https://placehold.co/40x40/D35400/FFF?text=👤';
                }
                showOverlay(userSettingsOverlay);
            });
            closeUserSettingsBtn.addEventListener('click', () => hideOverlay(userSettingsOverlay));
            
            saveSettingsBtn.addEventListener('click', async () => {
                const newDisplayName = settingsUsernameInput.value.trim();

                try {
                    if (newDisplayName && newDisplayName !== currentUser.displayName) {
                        await updateProfile(currentUser, { displayName: newDisplayName });
                        const userDocRef = doc(db, "users", currentUser.uid);
                        await updateDoc(userDocRef, { displayName: newDisplayName });
                    }
                    
                    showInfoModal("設定を保存しました。");
                    hideOverlay(userSettingsOverlay);
                    initAppForUser(currentUser); 
                } catch (error) {
                    showInfoModal("設定の保存に失敗しました。");
                    console.error("Settings save error:", error);
                }
            });
            
            iconUploadBtn.addEventListener('click', () => iconUploadInput.click());
            
            iconUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    cropperImage.src = event.target.result;
                    showOverlay(cropperOverlay);
                    
                    if (cropper) {
                        cropper.destroy();
                    }
                    
                    cropper = new Cropper(cropperImage, {
                        aspectRatio: 1,
                        viewMode: 1,
                        background: false,
                        autoCropArea: 0.8,
                    });
                };
                reader.readAsDataURL(file);
                iconUploadInput.value = ''; 
            });

            cropperCancelBtn.addEventListener('click', () => {
                hideOverlay(cropperOverlay);
                if(cropper) cropper.destroy();
            });

            cropperSaveBtn.addEventListener('click', async () => {
                if (!cropper || !currentUser) return;

                iconUploadSpinner.classList.remove('hidden');
                cropperSaveBtn.disabled = true;

                cropper.getCroppedCanvas({
                    width: 256,
                    height: 256,
                    imageSmoothingQuality: 'high',
                }).toBlob(async (blob) => {
                    const storageRef = ref(storage, `profile_icons/${currentUser.uid}`);
                    
                    try {
                        const snapshot = await uploadBytes(storageRef, blob);
                        const downloadURL = await getDownloadURL(snapshot.ref);

                        await updateProfile(currentUser, { photoURL: downloadURL });
                        await updateDoc(doc(db, "users", currentUser.uid), { photoURL: downloadURL });

                        showInfoModal("アイコンを更新しました。");
                        initAppForUser(currentUser); 
                    } catch (error) {
                        console.error("Icon upload error: ", error);
                        showInfoModal("アイコンのアップロードに失敗しました。");
                    } finally {
                        iconUploadSpinner.classList.add('hidden');
                        cropperSaveBtn.disabled = false;
                        hideOverlay(cropperOverlay);
                        if(cropper) cropper.destroy();
                    }
                }, 'image/png');
            });


            userSwitcher.addEventListener('change', (e) => {
                const selectedUserId = e.target.value;
                if (selectedUserId) {
                    const selectedUserName = e.target.options[e.target.selectedIndex].text;
                    viewUserPlan(selectedUserId, selectedUserName);
                } else {
                    viewUserPlan(currentUser.uid, currentUser.displayName || 'ゲスト');
                }
            });

            addSpotBtn.addEventListener('click', () => {
                showOverlay(addSpotOverlay);
            });
            closeAddSpotBtn.addEventListener('click', () => {
                hideOverlay(addSpotOverlay);
            });
            submitSpotBtn.addEventListener('click', async () => {
                const spotName = newSpotName.value.trim();
                const spotUrl = newSpotUrl.value.trim();

                if (!spotName || !spotUrl) {
                    showInfoModal("スポット名とURLの両方を入力してください。");
                    return;
                }
                if (spotName.length < 3) {
                    showInfoModal("スポット名は3文字以上で入力してください。");
                    return;
                }
                try {
                    new URL(spotUrl);
                } catch (_) {
                    showInfoModal("有効なURLを入力してください。");
                    return;
                }
                if (!currentUser) {
                    showInfoModal("ログインが必要です。");
                    return;
                }
                if (combinedSpots.some(spot => spot.name === spotName)) {
                    showInfoModal("このスポットは既に登録されています。");
                    return;
                }

                submitSpotSpinner.classList.remove('hidden');
                submitSpotBtn.disabled = true;
                
                try {
                    const analyzeSpotSuggestion = httpsCallable(functions, 'analyzeSpotSuggestion');
                    const result = await analyzeSpotSuggestion({
                        spotName: spotName,
                        spotUrl: spotUrl,
                        areaPositions: areaPositions,
                        standardTags: standardTags
                    });
                    
                    const aiData = result.data;

                    if (!aiData.isNameConsistent) {
                        showInfoModal("提案されたスポット名と公式サイトの内容が一致しないようです。");
                        submitSpotSpinner.classList.add('hidden');
                        submitSpotBtn.disabled = false;
                        return;
                    }
                    if (!aiData.prefecture || !supportedPrefectureNames.includes(aiData.prefecture)) {
                        pendingReAnalysisData = { ...aiData, originalName: spotName, originalUrl: spotUrl };
                        showOverlay(reAnalysisOverlay);
                        submitSpotSpinner.classList.add('hidden');
                        submitSpotBtn.disabled = false;
                        return; 
                    }

                    await addDoc(collection(db, "spot_submissions"), {
                        ...aiData,
                        originalName: spotName,
                        originalUrl: spotUrl,
                        submittedBy: currentUser.uid,
                        submittedAt: serverTimestamp(),
                        status: "pending"
                    });

                    showInfoModal("スポットの提案を送信しました。管理者の承認をお待ちください。");
                    newSpotName.value = '';
                    newSpotUrl.value = '';
                    hideOverlay(addSpotOverlay);

                } catch (error) {
                    console.error("AI分析または提案の送信に失敗しました:", error);
                    showInfoModal(`エラーが発生しました: ${error.message}`);
                } finally {
                    submitSpotSpinner.classList.add('hidden');
                    submitSpotBtn.disabled = false;
                }
            });
            
            closeReAnalysisBtn.addEventListener('click', () => hideOverlay(reAnalysisOverlay));
            
            reSubmitSpotBtn.addEventListener('click', async () => {
                 const gmapsUrl = reAnalysisGmapsUrl.value.trim();
                 if (!gmapsUrl) {
                     showInfoModal("GoogleマップのURLを入力してください。");
                     return;
                 }
                 reSubmitSpotSpinner.classList.remove('hidden');
                 reSubmitSpotBtn.disabled = true;

                 try {
                     const reAnalyzeSpotSuggestion = httpsCallable(functions, 'reAnalyzeSpotSuggestion');
                     const result = await reAnalyzeSpotSuggestion({
                         ...pendingReAnalysisData,
                         gmapsUrl: gmapsUrl,
                         areaPositions: areaPositions
                     });

                     const reAnalyzedData = result.data;
                     const finalData = { ...pendingReAnalysisData, ...reAnalyzedData };

                     if (!finalData.prefecture || !supportedPrefectureNames.includes(finalData.prefecture)) {
                         showInfoModal(`再分析しましたが、対応していない都道府県のようです。現在、${supportedPrefectureNames.join('、')}のスポットのみ提案を受け付けています。`);
                         return; 
                     }

                     await addDoc(collection(db, "spot_submissions"), {
                         ...finalData,
                         submittedBy: currentUser.uid,
                         submittedAt: serverTimestamp(),
                         status: "pending"
                     });

                     showInfoModal("スポットの提案を送信しました。管理者の承認をお待ちください。");
                     newSpotName.value = '';
                     newSpotUrl.value = '';
                     hideOverlay(addSpotOverlay);
                     hideOverlay(reAnalysisOverlay);

                 } catch(error) {
                      console.error("AI再分析または提案の送信に失敗しました:", error);
                      showInfoModal(`エラーが発生しました: ${error.message}`);
                 } finally {
                      reSubmitSpotSpinner.classList.add('hidden');
                      reSubmitSpotBtn.disabled = false;
                 }
            });

            function updateAdminBadgeUI() {
                const totalPending = pendingSpotSubmissionsCount + pendingImageReportsCount;
                submissionBadge.textContent = totalPending;
                submissionBadge.classList.toggle('hidden', totalPending === 0);

                imageReportBadge.textContent = pendingImageReportsCount;
                imageReportBadge.classList.toggle('hidden', pendingImageReportsCount === 0);
            }

            function listenForSubmissions() {
                const spotQuery = query(collection(db, "spot_submissions"), where("status", "==", "pending"));
                
                if (unsubscribeSpotSubmissions) unsubscribeSpotSubmissions();
                unsubscribeSpotSubmissions = onSnapshot(spotQuery, (snapshot) => {
                    submissionList.innerHTML = '';
                     if (snapshot.empty) {
                         submissionList.innerHTML = '<p class="text-center text-gray-500 py-10">承認待ちの提案はありません。</p>';
                    }
                    snapshot.forEach((doc) => {
                        renderSubmissionCard(doc.id, doc.data());
                    });
                    pendingSpotSubmissionsCount = snapshot.size;
                    updateAdminBadgeUI();
                }, (error) => {
                    console.error("Firestore permission error on spot_submissions:", error);
                    if (error.code === 'permission-denied') {
                        showInfoModal("管理者権限エラー: 提案リストの読み込みに失敗しました。アクセス権限を確認してください。");
                        hideOverlay(submissionPanelOverlay);
                        adminControls.classList.add('hidden');
                    }
                });
            }

            function listenForImageReports() {
                const reportQuery = query(collection(db, "image_reports"), where("status", "==", "pending"));
                
                if (unsubscribeImageReports) unsubscribeImageReports();
                unsubscribeImageReports = onSnapshot(reportQuery, (snapshot) => {
                    imageReportList.innerHTML = '';
                    if (snapshot.empty) {
                        imageReportList.innerHTML = '<p class="text-center text-gray-500 py-10">承認待ちの画像レポートはありません。</p>';
                    }
                    snapshot.forEach((doc) => {
                        renderImageReportCard(doc.id, doc.data());
                    });
                    pendingImageReportsCount = snapshot.size;
                    updateAdminBadgeUI();
                }, (error) => {
                    console.error("Firestore permission error on image_reports:", error);
                    if (error.code === 'permission-denied') {
                        showInfoModal("管理者権限エラー: 画像レポートの読み込みに失敗しました。");
                        imageReportList.innerHTML = '<p class="text-center text-red-500 py-10">権限エラーにより画像レポートを読み込めませんでした。</p>';
                    }
                });
            }

            function renderImageReportCard(id, data) {
                const card = document.createElement('div');
                card.id = `report-${id}`;
                card.className = 'bg-gray-50 p-4 rounded-lg border space-y-3';
                
                const date = data.submittedAt ? data.submittedAt.toDate().toLocaleString('ja-JP') : '日付不明';

                card.innerHTML = `
                    <div>
                        <h3 class="font-bold text-lg">${data.spotName}</h3>
                        <p class="text-sm text-gray-500">報告者: ${data.submittedBy.substring(0,8)}...</p>
                        <p class="text-sm text-gray-500">報告日時: ${date}</p>
                    </div>
                    <div class="flex items-center gap-4">
                        <p class="font-semibold text-sm">現在の画像:</p>
                        <img src="${data.currentImageUrl || 'https://placehold.co/100x75/ccc/FFF?text=N/A'}" class="w-24 h-auto rounded" onerror="this.parentElement.innerHTML = '<div class=\\'w-full h-32 bg-gray-200 flex items-center justify-center text-xs text-red-500 rounded-md\\'>画像読込失敗</div>'">
                    </div>
                    <div class="mt-4 space-y-2">
                        <div class="flex gap-2">
                            <button data-id="${id}" data-spot-name="${data.spotName}" data-prefecture="${data.prefecture}" data-current-image-url="${data.currentImageUrl}" class="update-image-ai-btn flex-1 bg-blue-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-blue-600">AIで候補を検索</button>
                            <button data-id="${id}" class="reject-report-btn flex-1 bg-red-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-600">却下</button>
                        </div>
                        <div class="border-t pt-2">
                            <p class="text-sm font-semibold text-gray-600 mb-1">または、手動でURLを更新:</p>
                            <div class="flex gap-2">
                                <input type="url" placeholder="新しい画像URL" class="manual-image-url-input flex-grow border-gray-300 rounded-md shadow-sm text-sm">
                                <button data-id="${id}" data-spot-name="${data.spotName}" data-prefecture="${data.prefecture}" class="manual-update-btn bg-gray-600 text-white py-2 px-3 rounded-lg font-semibold hover:bg-gray-700 text-xs">保存</button>
                            </div>
                        </div>
                    </div>
                `;
                imageReportList.appendChild(card);
            }

            function renderSubmissionCard(id, data) {
                const card = document.createElement('div');
                card.id = `submission-${id}`;
                card.className = 'bg-gray-50 p-4 rounded-lg border';
                
                const subCategoryOptions = subCategories[data.category] || [];

                card.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="font-bold text-lg">${data.name}</h3>
                            <p class="text-sm text-gray-500 mb-2">提案者: ${data.submittedBy.substring(0,8)}...</p>
                            <div class="flex gap-4 mb-2">
                                <a href="${data.website}" target="_blank" class="text-blue-600 hover:underline text-sm">公式サイト</a>
                                <a href="${data.gmaps}" target="_blank" class="text-blue-600 hover:underline text-sm">Googleマップ</a>
                            </div>
                        </div>
                        <div class="flex gap-2">
                             <button data-id="${id}" class="edit-btn text-sm bg-yellow-100 text-yellow-800 py-1 px-3 rounded-full hover:bg-yellow-200">編集</button>
                             <button data-id="${id}" class="save-btn text-sm bg-blue-100 text-blue-800 py-1 px-3 rounded-full hover:bg-blue-200 hidden">保存</button>
                        </div>
                    </div>
                    <div class="bg-white p-3 rounded-md border text-sm space-y-3 mt-2 admin-edit-form">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label class="font-bold">カテゴリ</label>
                                <select name="category" disabled>
                                    <option value="観光" ${data.category === '観光' ? 'selected' : ''}>観光</option>
                                    <option value="グルメ" ${data.category === 'グルメ' ? 'selected' : ''}>グルメ</option>
                                </select>
                            </div>
                            <div>
                                <label class="font-bold">サブカテゴリ</label>
                                <select name="subCategory" disabled>
                                    ${subCategoryOptions.map(opt => `<option value="${opt}" ${data.subCategory === opt ? 'selected' : ''}>${opt}</option>`).join('')}
                                </select>
                            </div>
                        </div>
                        <div>
                            <div class="flex justify-between items-center">
                                <label class="font-bold">説明文</label>
                                <button data-id="${id}" class="regenerate-description-btn text-xs bg-purple-100 text-purple-800 py-1 px-2 rounded-full hover:bg-purple-200 flex items-center gap-1">
                                    <svg class="w-3 h-3" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                                    <span>AIで再生成</span>
                                    <div class="spinner w-3 h-3 border-t-2 border-b-2 border-purple-800 rounded-full animate-spin hidden"></div>
                                </button>
                            </div>
                            <textarea name="description" rows="4" disabled>${data.description}</textarea>
                        </div>
                        <div>
                            <label class="font-bold">タグ</label>
                            <div class="tag-checkbox-group">
                                ${standardTags.map(tag => `
                                    <label class="tag-checkbox">
                                        <input type="checkbox" name="tags" value="${tag}" ${(data.tags || []).includes(tag) ? 'checked' : ''} disabled>
                                        <span class="ml-2 text-xs">${tag}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        ${data.isNewArea ? `
                        <div class="mt-3 p-3 bg-orange-50 border-l-4 border-orange-400">
                            <h4 class="font-bold text-orange-800">新規エリアの提案が含まれています</h4>
                            <p class="text-sm text-orange-700">スポット「${data.name}」は新しいエリア「${data.area}」に属しています。</p>
                            <label class="mt-2 inline-flex items-center">
                                <input type="checkbox" name="approveNewArea" class="rounded border-gray-300 text-orange-600 shadow-sm focus:border-orange-300 focus:ring focus:ring-offset-0 focus:ring-orange-200 focus:ring-opacity-50">
                                <span class="ml-2 text-sm font-medium text-orange-800">この新しいエリアも同時に承認する</span>
                            </label>
                        </div>
                        ` : ''}
                    </div>
                    <div class="mt-4 flex gap-4">
                        <button data-id="${id}" class="approve-btn flex-1 bg-green-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-green-600">承認</button>
                        <button data-id="${id}" class="reject-btn flex-1 bg-red-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-red-600">却下</button>
                    </div>
                `;
                submissionList.appendChild(card);
            }
            
            openSubmissionPanelBtn.addEventListener('click', () => {
                showOverlay(submissionPanelOverlay);
            });
            closeSubmissionPanelBtn.addEventListener('click', () => hideOverlay(submissionPanelOverlay));

            submissionList.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                const submissionId = target.dataset.id;
                if (!submissionId) return;
                
                const card = document.getElementById(`submission-${submissionId}`);
                const form = card.querySelector('.admin-edit-form');

                if (target.classList.contains('edit-btn')) {
                    form.querySelectorAll('input, textarea, select').forEach(el => el.disabled = false);
                    target.classList.add('hidden');
                    card.querySelector('.save-btn').classList.remove('hidden');
                } else if (target.classList.contains('save-btn')) {
                    const updatedData = {
                        category: form.querySelector('[name="category"]').value,
                        subCategory: form.querySelector('[name="subCategory"]').value,
                        description: form.querySelector('[name="description"]').value,
                        tags: Array.from(form.querySelectorAll('[name="tags"]:checked')).map(el => el.value)
                    };
                    
                    target.disabled = true;
                    target.textContent = '保存中...';
                    
                    try {
                        const submissionRef = doc(db, "spot_submissions", submissionId);
                        await updateDoc(submissionRef, updatedData);
                        showInfoModal("提案内容を更新しました。");
                    } catch (error) {
                        console.error("提案の更新に失敗:", error);
                        showInfoModal("更新に失敗しました。");
                    } finally {
                        form.querySelectorAll('input, textarea, select').forEach(el => el.disabled = true);
                        target.classList.add('hidden');
                        card.querySelector('.edit-btn').classList.remove('hidden');
                        target.disabled = false;
                        target.textContent = '保存';
                    }
                } else if (target.classList.contains('regenerate-description-btn')) {
                    const spinner = target.querySelector('.spinner');
                    const buttonText = target.querySelector('span');
                    spinner.classList.remove('hidden');
                    buttonText.classList.add('hidden');
                    target.disabled = true;

                    try {
                        const submissionRef = doc(db, "spot_submissions", submissionId);
                        const submissionSnap = await getDoc(submissionRef);
                        if(submissionSnap.exists()) {
                            const data = submissionSnap.data();
                            const regenerateDescription = httpsCallable(functions, 'regenerateDescription');
                            const result = await regenerateDescription({
                                originalName: data.originalName,
                                originalUrl: data.originalUrl
                            });
                            
                            const newDescription = result.data.description;
                            
                            form.querySelector('[name="description"]').value = newDescription;
                            await updateDoc(submissionRef, { description: newDescription });
                            showInfoModal("説明文を再生成しました。内容を確認し、必要であれば保存してください。");
                        }
                    } catch (error) {
                        console.error("説明文の再生成に失敗:", error);
                        showInfoModal(`説明文の再生成に失敗しました: ${error.message}`);
                    } finally {
                        spinner.classList.add('hidden');
                        buttonText.classList.remove('hidden');
                        target.disabled = false;
                    }

                } else if (target.classList.contains('approve-btn')) {
                    target.disabled = true;
                    target.textContent = '承認中...';
                    try {
                        const submissionRef = doc(db, "spot_submissions", submissionId);
                        const submissionSnap = await getDoc(submissionRef);
                        if (submissionSnap.exists()) {
                            const approveSubmission = httpsCallable(functions, 'approveSubmission');
                            await approveSubmission({
                                submissionId: submissionId,
                                submissionData: submissionSnap.data(),
                                approveNewArea: card.querySelector('[name="approveNewArea"]')?.checked || false
                            });
                            await reloadDataAndRefreshUI("データの更新をリクエストしました。\n反映には数分かかる場合があります。");
                        }
                    } catch (error) {
                        console.error("承認処理に失敗:", error);
                        showInfoModal(`承認処理に失敗しました: ${error.message}`);
                    } finally {
                        target.disabled = false;
                        target.textContent = '承認';
                    }
                } else if (target.classList.contains('reject-btn')) {
                    target.disabled = true;
                    target.textContent = '却下中...';
                    const submissionRef = doc(db, "spot_submissions", submissionId);
                    await deleteDoc(submissionRef);
                    showInfoModal("提案を却下しました。");
                }
            });

            mailboxBtn.addEventListener('click', () => {
                myPlanPanelOverlay.classList.remove('hidden');
                mailboxPanel.classList.remove('translate-x-full');
                toggleBodyScroll(true);
            });

            const closeMailboxPanel = async () => {
                mailboxPanel.classList.add('translate-x-full');
                myPlanPanelOverlay.classList.add('hidden');
                toggleBodyScroll(false);

                // Mark personal notifications as read in Firestore
                if (currentUser && !currentUser.isAnonymous) {
                    const unreadQuery = query(collection(db, "users", currentUser.uid, "mailbox"), where("read", "==", false));
                    try {
                        const unreadSnapshot = await getDocs(unreadQuery);
                        if (!unreadSnapshot.empty) {
                            const batch = writeBatch(db);
                            unreadSnapshot.forEach(doc => {
                                batch.update(doc.ref, { read: true });
                            });
                            await batch.commit();
                        }
                    } catch (error) {
                        console.error("Error marking personal notifications as read:", error);
                    }
                }

                // Mark public announcements as read in localStorage
                const latestTimestamp = Math.max(0, ...localAnnouncements.map(n => n.createdAt?.toMillis() || 0));
                localStorage.setItem('lastReadAnnouncementTimestamp', latestTimestamp);
                
                mailboxBadge.classList.add('hidden');
            };
            mailboxCloseBtn.addEventListener('click', closeMailboxPanel);
            mailboxPanelOverlay.addEventListener('click', closeMailboxPanel);

            function renderMailbox(docs, lastReadTimestamp) {
                mailboxList.innerHTML = '';
                if (docs.length === 0) {
                    mailboxList.innerHTML = '<p class="text-center text-gray-500 py-10">お知らせはありません。</p>';
                    return;
                }
                
                docs.forEach(docData => {
                    const isRead = docData.type === 'personal' ? docData.read : (docData.createdAt?.toMillis() || 0) <= lastReadTimestamp;
                    const item = document.createElement('div');
                    item.className = `p-4 border-b ${!isRead ? 'bg-orange-50 font-bold' : 'bg-white'}`;
                    
                    const date = docData.createdAt ? docData.createdAt.toDate().toLocaleString('ja-JP') : '日付不明';

                    item.innerHTML = `
                        <h4 class="text-md ${!isRead ? 'text-orange-800' : 'text-gray-800'}">${docData.title}</h4>
                        <p class="text-sm mt-1 ${!isRead ? 'text-orange-700' : 'text-gray-600'}">${docData.message}</p>
                        <p class="text-xs text-gray-400 mt-2 text-right">${date}</p>
                    `;
                    mailboxList.appendChild(item);
                });
            }
            
            markAllAsReadBtn.addEventListener('click', async () => {
                if (!currentUser || currentUser.isAnonymous) return;
                
                // Mark personal notifications as read in Firestore
                const unreadQuery = query(collection(db, "users", currentUser.uid, "mailbox"), where("read", "==", false));
                try {
                    const unreadSnapshot = await getDocs(unreadQuery);
                    if (!unreadSnapshot.empty) {
                        const batch = writeBatch(db);
                        unreadSnapshot.forEach(doc => {
                            batch.update(doc.ref, { read: true });
                        });
                        await batch.commit();
                    }
                } catch (error) {
                    console.error("Error in markAllAsReadBtn for personal notifications:", error);
                }

                // Mark public announcements as read in localStorage
                const latestTimestamp = Math.max(0, ...localAnnouncements.map(n => n.createdAt?.toMillis() || 0));
                localStorage.setItem('lastReadAnnouncementTimestamp', latestTimestamp);
            });

            // --- Batch Image Update Logic (MODIFIED) ---

            const startBatchUpdate = async (prefectureId) => {
                hideOverlay(batchUpdatePrefectureSelectOverlay); // Hide selection modal
                showOverlay(batchImageUpdateOverlay);
                batchUpdateList.innerHTML = '';
                batchUpdateList.classList.add('hidden');
                batchUpdateLoading.classList.remove('hidden');
                batchUpdateConfirmBtn.disabled = true;
                batchUpdateCount.textContent = '0';
                batchUpdateSelectAll.checked = false;

                try {
                    const batchFindImageUpdatesCallable = httpsCallable(functions, 'batchFindImageUpdates');
                    const result = await batchFindImageUpdatesCallable({ prefectureId: prefectureId });
                    proposedImageUpdates = result.data;
                    
                    batchUpdateLoading.classList.add('hidden');
                    batchUpdateList.classList.remove('hidden');

                    if (proposedImageUpdates.length === 0) {
                        batchUpdateList.innerHTML = '<p class="text-center text-gray-500 py-10">更新対象の画像はありませんでした。</p>';
                        return;
                    }

                    proposedImageUpdates.forEach((update, index) => {
                        const item = document.createElement('div');
                        item.className = 'p-4 border rounded-lg bg-gray-50';
                        item.innerHTML = `
                            <div class="flex items-start gap-4">
                                <input type="checkbox" data-index="${index}" class="batch-update-checkbox mt-1 h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded">
                                <div class="flex-grow">
                                    <p class="font-bold">${update.spotName}</p>
                                    <p class="text-sm text-gray-500">${update.prefecture} / ${update.area}</p>
                                    <div class="update-item-grid mt-2">
                                        <img src="${update.oldImageUrl}" alt="古い画像" onerror="this.src='https://placehold.co/200x150/ccc/FFF?text=Error'">
                                        <span class="update-item-arrow">→</span>
                                        <img src="${update.newImageUrl}" alt="新しい画像" onerror="this.src='https://placehold.co/200x150/ccc/FFF?text=Error'">
                                    </div>
                                </div>
                            </div>
                        `;
                        batchUpdateList.appendChild(item);
                    });

                } catch (error) {
                    console.error("Error fetching batch image updates:", error);
                    batchUpdateLoading.classList.add('hidden');
                    batchUpdateList.classList.remove('hidden');
                    batchUpdateList.innerHTML = `<p class="text-center text-red-500 py-10">更新候補の取得に失敗しました。<br>${error.message}</p>`;
                }
            };
            
            const renderBatchUpdatePrefectureMap = () => {
                // Remove any existing buttons
                while (batchUpdatePrefectureMapContainer.firstChild) {
                    if (batchUpdatePrefectureMapContainer.firstChild.tagName !== 'IMG') {
                        batchUpdatePrefectureMapContainer.removeChild(batchUpdatePrefectureMapContainer.firstChild);
                    } else {
                        break; // Stop when we hit the image
                    }
                }
                const existingButtons = batchUpdatePrefectureMapContainer.querySelectorAll('.prefecture-map-button');
                existingButtons.forEach(btn => btn.remove());


                const options = Array.from(prefectureFilter.options);
                options.forEach(option => {
                    if (option.value === 'all') return;
                    const prefId = option.value;
                    const pos = prefectureMapPositions[prefId];
                    if (pos) {
                        const btn = document.createElement('button');
                        btn.className = 'prefecture-map-button';
                        btn.textContent = option.textContent.charAt(0);
                        btn.title = option.textContent;
                        btn.dataset.prefectureId = prefId;
                        btn.style.top = pos.top;
                        btn.style.left = pos.left;
                        batchUpdatePrefectureMapContainer.appendChild(btn);
                    }
                });
            };

            const renderBatchUpdatePrefectureList = () => {
                batchUpdatePrefectureListContainer.innerHTML = '';
                const allBtn = document.createElement('button');
                allBtn.className = 'w-full py-2 px-6 bg-blue-500 text-white rounded-lg font-semibold hover:bg-blue-600';
                allBtn.textContent = 'すべての都道府県';
                allBtn.dataset.prefectureId = 'all';
                batchUpdatePrefectureListContainer.appendChild(allBtn);

                const options = Array.from(prefectureFilter.options);
                for (let i = 1; i < options.length; i++) {
                    const option = options[i];
                    const prefBtn = document.createElement('button');
                    prefBtn.className = 'w-full py-2 px-6 bg-white border border-gray-300 rounded-lg font-semibold hover:bg-gray-100';
                    prefBtn.textContent = option.textContent;
                    prefBtn.dataset.prefectureId = option.value;
                    batchUpdatePrefectureListContainer.appendChild(prefBtn);
                }
            };

            const renderBatchUpdateSelectView = () => {
                batchUpdateViewSwitcher.querySelectorAll('button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.view === batchUpdatePrefectureView);
                });
                if (batchUpdatePrefectureView === 'map') {
                    batchUpdatePrefectureMapContainer.classList.remove('hidden');
                    batchUpdatePrefectureListContainer.classList.add('hidden');
                    renderBatchUpdatePrefectureMap();
                } else {
                    batchUpdatePrefectureMapContainer.classList.add('hidden');
                    batchUpdatePrefectureListContainer.classList.remove('hidden');
                    renderBatchUpdatePrefectureList();
                }
            };

            batchUpdateImagesBtn.addEventListener('click', () => {
                renderBatchUpdateSelectView();
                showOverlay(batchUpdatePrefectureSelectOverlay);
            });

            batchUpdateViewSwitcher.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && button.dataset.view) {
                    batchUpdatePrefectureView = button.dataset.view;
                    renderBatchUpdateSelectView();
                }
            });

            batchUpdatePrefectureMapContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && button.dataset.prefectureId) {
                    startBatchUpdate(button.dataset.prefectureId);
                }
            });

            batchUpdatePrefectureListContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && button.dataset.prefectureId) {
                    startBatchUpdate(button.dataset.prefectureId);
                }
            });
            
            batchUpdatePrefectureSelectCancelBtn.addEventListener('click', () => {
                hideOverlay(batchUpdatePrefectureSelectOverlay);
            });


            function updateBatchConfirmButton() {
                const checkedCount = batchUpdateList.querySelectorAll('.batch-update-checkbox:checked').length;
                batchUpdateCount.textContent = checkedCount;
                batchUpdateConfirmBtn.disabled = checkedCount === 0;
            }

            batchUpdateList.addEventListener('change', (e) => {
                if (e.target.classList.contains('batch-update-checkbox')) {
                    updateBatchConfirmButton();
                }
            });

            batchUpdateSelectAll.addEventListener('change', (e) => {
                batchUpdateList.querySelectorAll('.batch-update-checkbox').forEach(checkbox => {
                    checkbox.checked = e.target.checked;
                });
                updateBatchConfirmButton();
            });

            batchUpdateConfirmBtn.addEventListener('click', async () => {
                const selectedIndices = Array.from(batchUpdateList.querySelectorAll('.batch-update-checkbox:checked'))
                    .map(cb => parseInt(cb.dataset.index, 10));
                
                if (selectedIndices.length === 0) {
                    showInfoModal("更新する画像を選択してください。");
                    return;
                }

                const updatesToConfirm = selectedIndices.map(index => proposedImageUpdates[index]);
                
                showConfirmationModal(
                    `${selectedIndices.length}件の画像を本当に更新しますか？\nこの操作は元に戻せません。`,
                    "更新を実行",
                    "bg-blue-500",
                    async () => {
                        hideOverlay(batchImageUpdateOverlay);
                        showInfoModal("画像の更新処理を開始しました。完了まで数分かかる場合があります...");
                        try {
                            const confirmImageUpdatesCallable = httpsCallable(functions, 'confirmImageUpdates');
                            const result = await confirmImageUpdatesCallable({ updates: updatesToConfirm });
                            await reloadDataAndRefreshUI(result.data.message || "画像の更新が完了しました。");
                        } catch (error) {
                            console.error("Error confirming image updates:", error);
                            showInfoModal(`画像の更新に失敗しました: ${error.message}`);
                        }
                    }
                );
            });

            batchUpdateCloseBtn.addEventListener('click', () => hideOverlay(batchImageUpdateOverlay));
            batchUpdateCancelBtn.addEventListener('click', () => hideOverlay(batchImageUpdateOverlay));
            
            // --- Image Report Logic ---
            reportImageBtn.addEventListener('click', async () => {
                const spotName = modal.dataset.spotName;
                const spot = combinedSpots.find(s => s.name === spotName);
                if (!spot || !currentUser) return;

                const reportsRef = collection(db, "image_reports");
                const q = query(reportsRef, where("spotName", "==", spotName), where("status", "==", "pending"));
                const querySnapshot = await getDocs(q);
                if (!querySnapshot.empty) {
                    showInfoModal("このスポットの画像は既に報告されています。");
                    return;
                }

                showConfirmationModal(
                    `「${spotName}」の画像がスポットと無関係、または不適切であると報告しますか？`,
                    "報告する",
                    "bg-red-500",
                    async () => {
                        try {
                            await addDoc(collection(db, "image_reports"), {
                                spotName: spot.name,
                                prefecture: spot.prefecture,
                                currentImageUrl: spot.image,
                                submittedBy: currentUser.uid,
                                submittedAt: serverTimestamp(),
                                status: "pending"
                            });
                            showInfoModal("ご報告ありがとうございます。管理者が確認します。");
                            closeModal();
                        } catch (error) {
                            console.error("Error submitting image report:", error);
                            showInfoModal("報告の送信に失敗しました。");
                        }
                    }
                );
            });

            imageReportList.addEventListener('click', async (e) => {
                const target = e.target.closest('button');
                if (!target) return;

                const reportId = target.dataset.id;
                if (!reportId) return;
                
                const card = document.getElementById(`report-${reportId}`);
                const spotName = target.dataset.spotName;
                const prefecture = target.dataset.prefecture;

                if (target.classList.contains('reject-report-btn')) {
                    showConfirmationModal(`この画像レポートを却下しますか？`, '却下する', 'bg-red-500', async () => {
                        await deleteDoc(doc(db, "image_reports", reportId));
                        showInfoModal("レポートを却下しました。");
                    });

                } else if (target.classList.contains('update-image-ai-btn')) {
                    activeImageReportData = { reportId, spotName, prefecture };
                    
                    showOverlay(imageCandidateOverlay);
                    imageCandidateList.innerHTML = '';
                    imageCandidateList.classList.add('hidden');
                    imageCandidateLoading.classList.remove('hidden');
                    imageCandidateConfirmBtn.disabled = true;

                    try {
                        const fetchImageForSpotCallable = httpsCallable(functions, 'fetchImageForSpot');
                        const result = await fetchImageForSpotCallable({
                            spot: { name: spotName, area: combinedSpots.find(s => s.name === spotName)?.area || '' },
                            prefectureName: prefecture,
                            reportedImageUrl: target.dataset.currentImageUrl
                        });
                        displayImageCandidates(result.data.candidates);
                    } catch (error) {
                        console.error("Error fetching image candidates:", error);
                        showInfoModal(`画像候補の取得に失敗しました: ${error.message}`);
                        hideOverlay(imageCandidateOverlay);
                    } finally {
                        imageCandidateLoading.classList.add('hidden');
                        imageCandidateList.classList.remove('hidden');
                    }

                } else if (target.classList.contains('manual-update-btn')) {
                    const urlInput = card.querySelector('.manual-image-url-input');
                    const newImageUrl = urlInput.value.trim();
                    if (!newImageUrl) {
                        showInfoModal("新しい画像URLを入力してください。");
                        return;
                    }
                    target.disabled = true;
                    target.textContent = '保存中...';
                     try {
                        const resolveImageReport = httpsCallable(functions, 'resolveImageReport');
                        await resolveImageReport({ reportId, spotName, newImageUrl, prefecture });
                        await reloadDataAndRefreshUI("データの更新をリクエストしました。\n反映には数分かかる場合があります。");
                    } catch (error) {
                         showInfoModal(`手動での画像更新に失敗しました: ${error.message}`);
                         console.error("Error resolving image report manually:", error);
                    } finally {
                        target.disabled = false;
                        target.textContent = '保存';
                    }
                }
            });
            
            function displayImageCandidates(candidates) {
                imageCandidateList.innerHTML = '';
                if (!candidates || candidates.length === 0) {
                    imageCandidateList.innerHTML = `<p class="col-span-full text-center text-gray-500 py-10">適切な画像候補が見つかりませんでした。</p>`;
                    return;
                }

                candidates.forEach(candidate => {
                    const div = document.createElement('div');
                    div.className = 'candidate-image-wrapper p-2 border-2 border-transparent rounded-lg cursor-pointer hover:border-blue-300 transition-all';
                    div.dataset.url = candidate.url;
                    div.innerHTML = `<img src="${candidate.url}" class="w-full h-32 object-cover rounded-md pointer-events-none" onerror="this.parentElement.innerHTML = '<div class=\\'w-full h-32 bg-gray-200 flex items-center justify-center text-xs text-red-500 rounded-md\\'>画像読込失敗</div>'">`;
                    imageCandidateList.appendChild(div);
                });
            }

            imageCandidateList.addEventListener('click', (e) => {
                const wrapper = e.target.closest('.candidate-image-wrapper');
                if (!wrapper) return;

                imageCandidateList.querySelectorAll('.candidate-image-wrapper').forEach(el => {
                    el.classList.remove('selected');
                });

                wrapper.classList.add('selected');
                imageCandidateConfirmBtn.disabled = false;
            });

            imageCandidateConfirmBtn.addEventListener('click', async () => {
                const selectedWrapper = imageCandidateList.querySelector('.selected');
                if (!selectedWrapper) {
                    showInfoModal("画像を選択してください。");
                    return;
                }

                const newImageUrl = selectedWrapper.dataset.url;
                const { reportId, spotName, prefecture } = activeImageReportData;

                imageCandidateConfirmBtn.disabled = true;
                imageCandidateConfirmBtn.textContent = '更新中...';

                try {
                    const resolveImageReport = httpsCallable(functions, 'resolveImageReport');
                    await resolveImageReport({ reportId, spotName, newImageUrl, prefecture });
                    await reloadDataAndRefreshUI("データの更新をリクエストしました。\n反映には数分かかる場合があります。");
                } catch (error) {
                    console.error("Error resolving image report with AI candidate:", error);
                    showInfoModal(`画像の更新に失敗しました: ${error.message}`);
                } finally {
                    imageCandidateConfirmBtn.disabled = false;
                    imageCandidateConfirmBtn.textContent = 'この画像に決定';
                }
            });
            
            imageCandidateCancelBtn.addEventListener('click', () => {
                hideOverlay(imageCandidateOverlay);
            });


            submissionTabs.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button) return;

                const tab = button.dataset.tab;
                submissionTabs.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');

                if (tab === 'submissions') {
                    submissionContent.classList.remove('hidden');
                    imageReportContent.classList.add('hidden');
                } else if (tab === 'image-reports') {
                    submissionContent.classList.add('hidden');
                    imageReportContent.classList.remove('hidden');
                }
            });

            searchInput.addEventListener('input', (e) => {
                currentSearchTerm = e.target.value.trim().toLowerCase();
                renderSpots();
            });

            sortOrder.addEventListener('change', (e) => {
                currentSortOrder = e.target.value;
                renderSpots();
            });

            // --- Image Viewer Logic ---
            function showImageViewer(imageUrl) {
                imageViewerImg.src = imageUrl;
                showOverlay(imageViewerOverlay);
            }

            userDisplay.addEventListener('click', (e) => {
                if(e.target.classList.contains('profile-icon')) {
                    showImageViewer(e.target.src);
                }
            });

            modalContent.addEventListener('click', (e) => {
                if(e.target.id === 'modal-image') {
                    showImageViewer(e.target.src);
                }
            });

            imageViewerOverlay.addEventListener('click', () => {
                hideOverlay(imageViewerOverlay);
            });
            
            mobileFilterToggle.addEventListener('click', () => {
                const isOpen = !navContentWrapper.classList.contains('hidden');
                navContentWrapper.classList.toggle('hidden');
                mobileFilterToggle.classList.toggle('open', !isOpen);
                mobileFilterToggleText.textContent = isOpen ? 'フィルターと検索を開く' : 'フィルターと検索を閉じる';
            });


            function renderAll() {
                renderSpots();
                renderPlan();
            }
            
            renderAll();
        });
    </script>
</body>
</html>
